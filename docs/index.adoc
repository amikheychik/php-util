= xTuple Utility package
:toc: left
:toclevels: 3
:icons: font
:source-highlighter: coderay
:source-language: php

== Subpackages

=== Collection

`Xtuple/Util/Collection` package provides classes to work with collections of elements. It contains abstract and default implementations for both strictly typed and untyped data. All collections are iterable and countable.

[NOTE]
PHP doesn't allow to use the word `List` as a namespace or a class name, so the term `Sequence` is used instead for the namespace and root interface. All the classes are named using the term `List`.

[NOTE]
PHP doesn't have a default mechanism for object identity, so the `Set` is defined not by elements' identity, but by their key method (similarly to `Map`).

Default implementation class path for any collection type follows the same pattern: `{Abstract Data Type}/{Implementation type}/{Narrowing customization}` (e.g. `Xtuple/Util/Collection/Map/ArrayMap/StrictType/StrictlyTypedArrayMap`).

Strict type abstract collections should be used to have generic collections. Original collection type interfaces should be extended to provide type information in PHPDocs.

Example: defining class to provide `ArrayList<stdClass>` list.

[source]
.ListStdClass.php - interface definition
----
<?php namespace Example\ArrayList;

use Xtuple\Util\Collection\Sequence\Sequence;

/**
 * List<stdClass> <1>
 */
interface ListStdClass
  extends Sequence { <2>
  /**
   * @return \stdClass|null <3>
   *
   * @param int $key
   */
  public function get(int $key);

  /**
   * @return \stdClass|null <4>
   */
  public function current();

  public function name(): string; <5>
}
----
<1> Optional hint in "generic" notation. May be useful for long and complicated data structures.
<2> Extending original list interface `Sequence`.
<3> Overriding `get()` definition, to specify `@return \stdClass|null` instead of `@return mixed|null`.
<4> Overriding `current()` definition, to specify return type. `Sequence::key()` doesn't need to be overridden, as its types are the same for all lists.
<5> Additional methods can be added to this type.

[NOTE]
`@generic` PHPDoc tag is used to mark interface methods that need to be overridden with more specific types.

[source]
.ArrayListStdClass.php - actual class implementation
----
<?php namespace Example\ArrayList;

use Xtuple\Util\Collection\Sequence\ArrayList\StrictType\AbstractStrictlyTypedArrayList;

/**
 * ArrayList<stdClass>
 */
final class ArrayListStdClass
  extends AbstractStrictlyTypedArrayList <1>
  implements ListStdClass { <2>
  /** @var string */
  private $name;
  /**
   * @param \stdClass[] $elements <3>
   * @param string      $name
   */
  public function __construct(array $elements = [], string $name = '') {
    parent::__construct(\stdClass::class, $elements); <4>
    $this->name = $name;
  }

  public function name(): string { <5>
    return $this->name;
  }
}
----
<1> `AbstractStrictlyTypedArrayList` automatically checks elements' types.
<2> Specify implemented interface to reference overridden `get()` and `current()` methods.
<3> Overriding constructor PHPDoc to narrow type hint (`@param \stdClass[] $elements` instead of `@param array $elements`) and hide `$type` parameter
<4> Pass exact type `stdClass` into parent constructor.
<5> Implementation of the additional method defined in `ListStdClass`.

==== List (Sequence)

`Xtuple/Util/Collection/Sequence` package provides default list implementations. List keys are integers and count starts from `0`. List allows access to any existing element with `get(int $key)` method. List is immutable.

[source]
.Example usage of the `ArrayList`.
----
use Xtuple\Util\Collection\Sequence\ArrayList\ArrayList;

// Lists remove all the array keys, and start numeration from 0.
$list = new ArrayList(['one' => 1, 'two' => 2, 'three' => 3]);

// Returns 2, as 'two' is removed.
$list->get(1);
----

[source]
.Example usage of the `StrictlyTypedArrayList`.
----
use Xtuple\Util\Collection\Sequence\ArrayList\StrictType\StrictlyTypedArrayList;

// Effectively, $list is List<Countable>
$list = new StrictlyTypedArrayList(\Countable::class, [
  new \ArrayObject([1]),
  new \ArrayObject([1, 2]),
]);

$list->get(0)->count(); // returns 1

foreach ($list as $k => $value) {
  // \Countable interface methods can be used without a type check, as type is checked on input.
  $value->count();
}
----

==== Map

`Xtuple/Util/Collection/Map` package provides default key-value map implementations. Unlike usual key-value maps, Map keys are always strings (not objects). Map allows access to any existing element with `get(string $key)` method. Map is immutable.

[source]
.Example usage of the `ArrayMap`.
----
use Xtuple\Util\Collection\Map\ArrayMap\ArrayMap;

// Array's default keys are casted to string
$map = new ArrayMap([1, 2 => 'two', 'three' => 3]);

// Note: parameter is string
$map->get('0'); // returns 1
$map->get('1'); // returns null
$map->get('2'); // returns 'two'
$map->get('three'); // returns 3

// Mapping callback can be specified to be used instead of default keys
$map = new ArrayMap([
  ['code' => 'US', 'name' => 'United States'],
  ['code' => 'CA', 'name' => 'Canada'],
], function ($element) {
  return $element['code'];
});

// Returns ['code' => 'US, 'name' => 'United States']
$map->get('US');
----

[source]
.Example usage of the `StrictlyTypedArrayMap`.
----
use Xtuple\Util\Collection\Map\ArrayMap\StrictType\StrictlyTypedArrayMap;

// $map is Map<string, stdClass>
$map = new StrictlyTypedArrayMap(\stdClass::class, [
  'US' => (object) ['code' => 'US', 'name' => 'United States'],
  'CA' => (object) ['code' => 'CA', 'name' => 'Canada'],
]);

// $key parameter can be specified to provide name of the key method. Key method must not require any parameters.
$map = new StrictlyTypedArrayMap(\Countable::class, [
  new \ArrayObject([1]),
  new \ArrayObject([1, 2]),
  new \ArrayObject([2]),
], 'count');

// Returns ArrayObject([1, 2]), as its count() returned 2
$map->get('2');

// Returns ArrayObject([2]), as it overrides earlier provided ArrayObject([1])
$map->get('1');
----

==== Set

`Xtuple/Util/Collection/Set` package provides default set implementation. As PHP doesn't support objects identity by default, its implementation can be chosen by user (two objects may be completely different, but would be considered identical, as long as their key method returns the same value). This effectively makes Set similar to Map, but unlike Map, Set throws exception when duplicates occur. Set is immutable.

[source]
.Example usage of the `ArraySet`.
----
use Xtuple\Util\Collection\Set\ArraySet\ArraySet;

// Array's default keys are casted to string
$map = new ArraySet([1, 2 => 'two', 'three' => 3]);
$map->get('0'); // returns 1
$map->get('1'); // returns null
$map->get('2'); // returns 'two'
$map->get('three'); // returns 3

// Mapping callback can be specified to be used instead of default keys
$map = new ArraySet([
  ['code' => 'US', 'name' => 'United States'],
  ['code' => 'CA', 'name' => 'Canada'],
], function ($element) {
  return $element['code'];
});

// Returns ['code' => 'US, 'name' => 'United States']
$map->get('US');

// Throws an exception, as 'code' => 'US' is duplicated.
$map = new ArraySet([
  ['code' => 'US', 'name' => 'United States'],
  ['code' => 'CA', 'name' => 'Canada'],
  ['code' => 'US', 'name' => 'USA'],
], function ($element) {
  return $element['code'];
});
----

[source]
.Example usage of the `StrictlyTypedArraySet`.
----
use Xtuple\Util\Collection\Set\ArraySet\StrictType\StrictlyTypedArraySet;

final class Country {
  /** @var array */
  private $data;
  public function __construct(array $data) {
    $this->data = $data;
  }
  public function code(): string { return $this->data['code']; }
  public function name(): string { return $this->data['name']; }
}

// $map is Set<Country>
$map = new StrictlyTypedArraySet(Country::class, [
  'US' => new Country(['code' => 'US', 'name' => 'United States']),
  'CA' => new Country(['code' => 'CA', 'name' => 'Canada']),
]);

// $key parameter can be specified to provide name of the key method. Key method must not require any parameters.
$map = new StrictlyTypedArraySet(Country::class, [
  new Country(['code' => 'US', 'name' => 'United States']),
  new Country(['code' => 'CA', 'name' => 'Canada']),
], 'code');

// Returns 'United States'
$map->get('US')->name();

// Throws an exception, as code 'US' is duplicated.
$map = new StrictlyTypedArraySet(Country::class, [
  new Country(['code' => 'US', 'name' => 'United States']),
  new Country(['code' => 'CA', 'name' => 'Canada']),
  new Country(['code' => 'US', 'name' => 'USA']),
], 'code');
----

==== Stack

`Xtuple/Util/Collection/Stack` package provides a default stack implementation. Similarly to List, stack keys are handled internally. Stack is mutable and provides `push()` and `pop()` methods to mutate its state.

[source]
.Example usage of the `ArrayStack`.
----
use Xtuple\Util\Collection\Stack\ArrayStack\ArrayStack;

// Initial state may be provided
$stack = new ArrayStack(['one', 'two']);

// Returns 3 - size of an updated stack
$stack->push('three');

// Returns 'three'
$stack->pop();
----

[source]
.Example usage of the `StrictlyTypedArrayStack`.
----
use Xtuple\Util\Collection\Stack\ArrayStack\StrictType\StrictlyTypedArrayStack;

//
$stack = new StrictlyTypedArrayStack(\stdClass:class, [
  (object) ['value' => 'one'],
  (object) ['value' => 'two'],
]);

// Returns 3 - size of an updated stack
$stack->push(['value' => 'three']);

// Returns 'three'
$stack->pop()->value;

// Throws an exception, as string is passed, not a \stdClass
$stack->push('three');
----

=== Exception

`Xtuple\Util\Exception` package provides a set of classes to throw translatable exceptions.

`Xtuple\Util\Exception\Throwable` is the base interface for all exceptions, and `Xtuple\Util\Exception\AbstractThrowable` is the base abstract class for all the exceptions. Unlike other packages, this package is not using decorators for abstract classes. Instead, `Xtuple\Util\Exception\AbstractThrowable` extends `\Exception` to utilize the default implementation of the `\Throwable` interface (3rd party PHP code usually catches `\Exception`, not `\Throwable`). All the implementations of `Xtuple\Util\Exception\AbstractThrowable` represent different shortcuts of its constructor.

`Xtuple\Util\Exception\Throwable` provides three methods:

* `message(): \Xtuple\Util\Type\String\Message\Message\Message` - translatable exception message.
* `exceptions(): \Xtuple\Util\Exception\Collection\Sequence\ListThrowable` - list of all previous exceptions, starting with the original exception.
* `errors(): \Xtuple\Util\Type\String\Message\Message\Collection\Sequence\ListMessage` - list of error messages, collection for the exception. This allows to throw one "final" exception for all occured issues (e.g. all errors from multiple async HTTP requests).

`Xtuple\Util\Exception\AbstractThrowable` provides final implementations for all these methods, and also overrides the default `__toString()`, to return information about all previous exceptions and all error messages inside them, instead of the stack trace for the exception.

==== Exception

`Xtuple\Util\Exception\ExceptionWithMessage` is a default implementation of `Xtuple\Util\Exception\AbstractThrowable`, without any constructor customizations. It may be especially helpful, when all the parameters are already provided in the required types.

[source]
----
use Xtuple\Util\Exception\ExceptionWithMessage;
use Xtuple\Util\Type\String\Message\Argument\Collection\Set\ArraySetArgument;
use Xtuple\Util\Type\String\Message\Message\MessageStruct;
use Xtuple\Util\Type\String\Message\Type\Number\Integer\IntegerArgument;
use Xtuple\Util\Type\String\Message\Type\String\StringArgument;

// $message might be returned from HTTP client
$message = new MessageStruct('HTTP error {code}: {message}', new ArraySetArgument([
  new IntegerArgument('code', 404),
  new StringArgument('message', 'Page not found'),
]));

throw new ExceptionWithMessage($message);
----

`Xtuple\Util\Exception\ExceptionWithArguments` is a shortcut for `Xtuple\Util\Exception\ExceptionWithMessage`, that encapsulates `Xtuple\Util\Type\String\Message\Message\MessageStruct`. It's useful, when non-string arguments are required.

[source]
----
use Xtuple\Util\Exception\ExceptionWithArguments;
use Xtuple\Util\Type\String\Message\Argument\Collection\Set\ArraySetArgument;
use Xtuple\Util\Type\String\Message\Type\Number\Integer\IntegerArgument;
use Xtuple\Util\Type\String\Message\Type\String\StringArgument;

throw new ExceptionWithMessage('HTTP error {code}: {message}', new ArraySetArgument([
  new IntegerArgument('code', 404),
  new StringArgument('message', 'Page not found'),
]));
----

`Xtuple\Util\Exception\Exception` is a shortcut for `Xtuple\Util\Exception\ExceptionWithMessage`, that encapsulates `Xtuple\Util\Type\String\Message\Message\MessageWithTokens` (as it's the most commonly used variant and requires the simplest form). All passed parameters are treated as string arguments (by `Xtuple\Util\Type\String\Message\Message\MessageWithTokens`).

[source]
----
use Xtuple\Util\Exception\Exception;

throw new Exception('HTTP error {code}: {message}', [
  'code' => 404, // this parameter would be cast to string and can't be localized as an integer later
  'message' => 'Page not found',
]));
----

==== ChainException

`Xtuple\Util\Exception\ChainException` is a shortcut for `Xtuple\Util\Exception\Exception` when a previous exception should be re-thrown.

[source]
----
use Xtuple\Util\Exception\ChainException;
use Xtuple\Util\Exception\Exception;

try {
  throw new Exception('HTTP error {code}: {message}', [
    'code' => 404,
    'message' => 'Page not found',
  ]));
}
catch (\Exception $e) {
  throw new ChainException($e, 'API request {request} failed', [
    'request' => 'api/v2/address',
  ]);
}
----

==== MultiErrorException

`Xtuple\Util\Exception\MultiErrorException` is a shortcut for `Xtuple\Util\Exception\Exception` when an exception with multiple errors should be thrown.

[source]
----
use Xtuple\Util\Exception\MultiErrorException;
use Xtuple\Util\Type\String\Message\Type\String\StringMessage;

// See https://secure.php.net/manual/en/function.curl-multi-strerror.php
$ch1 = curl_init('http://example.com/');
$ch2 = curl_init('http://php.net/');
$mh = curl_multi_init();
curl_multi_add_handle($mh, $ch1);
curl_multi_add_handle($mh, $ch2);
$errors = [];
do {
  $status = curl_multi_exec($mh, $active);
  if ($status > 0) {
    $errors[] = new StringMessage(curl_multi_strerror($status));
  }
} while ($status === CURLM_CALL_MULTI_PERFORM || $active);

if (!empty($errors)) {
  // Allow to log/process all occured errors, instead of throwing an exception after the first one has occured.
  throw new MultiErrorException($errors, 'HTTP requests failed');
}
----

=== File

==== Path

`Xtuple\Util\File\Path` package wraps path-related PHP functions into objects. Use `Path` to require interface, instead of using plain string to pass paths around. `Path` object represents only path, and may exist or does not exists, and should check for path status on each call.

[source]
----
use Xtuple\Util\File\Path\PathString;

$path = new PathString('/tmp/path-example');

// Returns false
$path->exists();

// Returns null as path doesn't exist
$path->absolute();

// Returns false
$path->isFile();

// Returns false
$path->isDir();

// Initializing file
touch('/tmp/path-example');

// Returns true
$path->exists();

// Returns "/tmp/path-example"
$path->absolute();

// Returns true
$path->isFile();
----

=== Generics

`Xtuple/Util/Generics` package simplifies work with generic classes.

==== Type

`Xtuple/Util/Generics/Type` package should be used when type check is required.

Use `StrictType` when instance of a class/interface is required, and `ScalarType` when a scalar (string, integer, float or boolean) is required.

[source]
----
use Xtuple\Util\Generics\Type\ScalarType;
use Xtuple\Util\Generics\Type\StrictType;

// Super types may be used.
$type = new StrictType(\Countable::class);

// Type::cast() method returns the same object instance as it receives, if type is correct.
$array1 = new \ArrayObject();
// Passes correctly, as \ArrayObject implements \Countable
$array2 = $type->cast($array1); // ($array1 === $array2)

// Throws an exception, as an array is passed
$type->cast([]);

// Throws an exception, as \stdClass does not implement \Countable;
$type->cast(new \stdClass());

$scalar = new ScalarType();

// Returns 1
$scalar->cast(1);

// Throws an exception, null is not a scalar.
$scalar->cast(null);
----

Use `NullableType` when instance of a class/interface or `null` can be passed, and `NullableScalarType` when a scalar or `null` can be passed.

[source]
----
use Xtuple\Util\Generics\Type\NullableScalarType;
use Xtuple\Util\Generics\Type\NullableType;

// Class/interface names may be passed as strings.
$nullableType = new NullableType('\stdClass'); <1>

// Returns null, instead of throwing an exception (unlike StrictType)
$nullableType->cast(null);

$nullableScalar = new NullabaleScalarType();

// Returns null, instead of throwin an exception
$nullalbeScalar->cast(null);
----
<1> `::class` constant doesn't have a leading root namespace `\`, but it's recommended to provide one when it's passed as a string.
