= xTuple Utility package
:toc: left
:toclevels: 3
:icons: font
:source-highlighter: coderay
:source-language: php

== Coding standards

=== Code style

https://www.jetbrains.com/help/phpstorm/settings-code-style.html[Code-style settings] are located in `Preferences → Editor → Code-Style`. Current file or all files in the selected directory can be https://www.jetbrains.com/help/phpstorm/using-code-editor.html#reformat_rearrange_code[reformatted] using `Code → Reformat Code` or `Code → Show Reformat Code Dialog` menus.

Code style has evolved from https://www.drupal.org/docs/develop/standards/coding-standards[Drupal coding standards], absorbing ideas from link:https://www.php-fig.org/psr/psr-1/[PSR-1]/link:https://www.php-fig.org/psr/psr-2/[PSR-2] and with regard to upcoming PHP language https://wiki.php.net/rfc[features]. The goals of the code style are:

* readability of the code;
* consistency of the code style;
* minimization of the diff/patch output.

==== Files

* Files _must_ use only UTF-8 without BOM.
* Files _must_ either declare symbols (classes, functions, constants, etc.) or cause side-effects (e.g. generate output, change .ini settings, etc.) but _must not_ do both.
** The phrase “side effects” means execution of logic not directly related to declaring classes, functions, constants, etc., _merely from including the file_.
* Files _must_ be formatted with `\n` as the line ending (Unix line endings), not `\r\n` (Windows line endings).
* All text files _must_ end in a single newline (`\n`). This avoids the verbose "\ No newline at end of file" patch warning and makes patches easier to read since it's clearer what is being changed when lines are added to the end of a file.
* Files _must_ use only full PHP tags `<?php ?>`, not shorthand `<? ?>`.
* Code _must not_ produce any warnings when PHP error reporting level is set to `E_ALL`.

===== Line length and wrapping

* All lines of code _should not_ be longer than `120` characters.
* The soft limit on line length _must_ be `120` characters.
** Automated style checkers _must_ warn but _must not_ error at the soft limit.
** Lines containing longer function names, function/class definitions, variable declarations, etc are allowed to exceed `120` characters.
* Lines _should not_ be longer than `80` characters:
** Lines longer than that _should_ be split into multiple subsequent lines of no more than `80` characters each.
* Single conditions _should not_ be wrapped into multiple lines.
** Multiple conditions _should be_ wrapped into multiple lines.
* Blank lines _must not_ be added to indicate related blocks of code.
* There _must not_ be more than one statement per line.
* Semicolons at the end of code blocks _must_ always be used, even when PHP allow them to be omitted.
* `example.com` _must_ be used for all example URLs, per https://tools.ietf.org/html/rfc2606[RFC 2606].
* Comment standards are discussed separately.

===== Indenting and Whitespace

* Code _must_ be indented by 2 spaces, with no tabs.
** Code inside PHP tags _must not_ be indented.
* Lines _must not_ have trailing whitespace at the end.

===== Braces

* Opening braces _must_ go on the same line.
* Closing braces _must_ go on the next line after the body.

===== File structure

The header of a PHP file may consist of a number of different blocks. If present, each of the blocks below _must_ be separated by a single blank line, and _must not_ contain a blank line. Each block _must_ be in the order listed below, although blocks that are not relevant may be omitted.

* PHP file _must_ start with the `<?php declare(strict_types=1);` line followed by a blank line.
* Opening `<?php declare(strict_type=1);` statement.
* File-level docblock.
* One or more remaining `declare` statements.
* The namespace declaration of the file.
* One or more class-based `use` import statements.
* One or more function-based `use` import statements.
* One or more constant-based `use` import statements.
* The remainder of the code in the file.
* Closing PHP tag `?>` _must_ be omitted in all files.

===== Including Code

* `require_once` _must_ be used for an unconditionally included file.
* `include_once` _must_ be used for a conditionally included file.
* `require` and `include` statements _must not_ be used.
* Parentheses _must not_ be used with `require_once` or `include_once` statements.
* File path _must_ start with `.`, when an included file is located in the same directory or a sub-directory.

===== Keywords

* PHP http://php.net/manual/en/reserved.keywords.php[keywords] and http://php.net/manual/en/reserved.keywords.php[reserved] *must* be lowercase, including predefined constants `true`, `false`, `null`.
* Short form of type keywords _must_ be used i.e. `bool` instead of `boolean`, `int` instead of `integer` etc.
* Pre-defined PHP constants (`true`, `false`, `null`) _must_ be lowercase (for consistency with all other PHP keywords).

==== Operators

* All binary operators (operators that come between two values), such as `+`, `-`, `=`, `!=`, `==`, `>`, etc. _must_ have a space before and after the operator, for readability.
* Unary operators (operators that operate on only one value), such as `++`, _must not_ have a space between the operator and the variable or number they are operating on.
* Checks _must_ use only `!==` operator.
** Weak-typed operands _must_ be explicitly casted.
* The `<>` operator _must not_ be used in PHP code.
* A space _must_ be used between the type and the variable in a cast.
* Ternary operator _must_ be split onto several lines
** The question mark and the colon _must be_ kept at the front of the line.
* The equal signs _must not_ be aligned in block-related assignments.
* Assignments _must_ be split onto several lines when the character/line limit would be exceeded.
** The equal sign has to be positioned onto the following line and indented once.

==== Control Structures

* Control structures include `if`, `for`, `while`, `switch`, etc.
* `elseif` _must_ always be used instead of `else if` (so that all control keywords look like single words).
* `else`, `elseif`, `while` (in `do…while`), `catch` _must_ be on a new line (so it's in the same column as `if`, `do`, `try` statements).
* The `case` statement _must_ be indented once from `switch`.
* The `break` keyword (or other terminating keyword) _must_ be indented at the same level as the `case` body.
* There _must_ be a comment such as `// no break` when fall-through is intentional in a non-empty `case` body.
* Long if statements _must_ be split onto several lines when the character/line limit would be exceeded.
** The conditions _must_ be positioned onto the following line, and indented once.
** The logical operators (`&&`, `||`, etc.) _must_ be at the beginning of the line to make it easier to comment (and exclude) the condition.
** The closing parenthesis and opening brace get their own line at the end of the conditions.
* Control statements should have one space between the control keyword and opening parenthesis, to distinguish them from function calls.
* Always use curly braces even in situations where they are technically optional. Having them increases readability and decreases the likelihood of logic errors being introduced when new lines are added.
* The opening curly should be on the same line as the opening statement, preceded by one space.
* The closing curly should be on a line by itself and indented to the same level as the opening statement.
* In templates, the alternate control statement syntax using `:` instead of brackets is allowed.
** There _must not_ be a space between the closing parenthesis after the control keyword, and the colon, and HTML/PHP inside the control structure should be indented.
* There _must_ be one space after the control structure keyword.
* There _must not_ be a space after the opening parenthesis.
* There _must not_ be a space before the closing parenthesis.
* There _must_ be one space between the closing parenthesis and the opening brace.
* The structure body _must_ be indented once.
* The closing brace _must_ be on the next line after the body.
* The body of each structure _must_ be enclosed by braces.
* Expressions in parentheses _may_ be split across multiple lines, where each subsequent line is indented at least once. When doing so, the first expression _must_ be on the next line. The closing parenthesis and opening brace _must_ be placed together on their own line with one space between them.

==== Arrays

* Arrays _must_ be formatted using short array syntax.
* Space separating each element (after the comma) _must_ be used.
* Spaces around the `=>` key association operator, if applicable, _must_ be used.
* Each element _must_ be broken into its own line, and indented one level, if the line declaring an array spans longer than `120` characters.
* Closing array bracket must be located on a new line, if the array is broken into multiple lines.
* Comma at the end of the last array element _must_ be used, if array is broken into multiple lines.

===== Strings

* Single quote strings _should_ be used by default.
* Use double quote string for a deliberate in-line variable interpolation.
** Curly brackets _must_ be used for interpolated variables.
* Use double quote string to avoid escaping single quotes.
* String concatenations _must not_ be used.
** String functions (like `strtr()`) or classes _must_ be used instead.

==== Classes and Interfaces

* Separate Interface definition _must_ be provided for each package.
* Classes/Interfaces (and their namespaces) _must_ follow an https://www.php-fig.org/psr/psr-4/[PSR-4: Autoloading Standard].
** File _must_ be named after the class.
** PSR-4 tree _must_ be located in `src` directory.
** Global classes _must not_ be declared.
* Classes/Interfaces _must_ use UpperCamelCase naming.
** Classes/Interfaces _should_ use short names and refer to their namespace for full name context (e.g. `Xtuple\Util\HTTP\Request\Request` instead of `Xtuple\Util\HTTP\Request\HTTPRequest`).
** Acronyms in the class/interface names _must_ be in all-uppercase.
** Underscores _must not_ be used.
** Class/Interface names _must not_ have "Class" or "Interface" words in the name.
** Test classes _must_ have the suffix "Test" (as required by PHPUnit).
* Only one class or interface per file _must_ be declared.
** Additional classes and interfaces _may_ be declared in test files, if used only internally.
* The `extends` and `implements` keywords _must_ be declared on the new line.
* The first implemented interface _must_ be declared on the same line with the `implements` word
** Each following interface _must_ be declared on its own line and indented to the same column as the first interface.
* Class/Interface declarations _must_ have their opening brace on the same line.
* An empty line between start of class/interface definition and property/method definition _must not_ be used.
* An empty line between end of method/property definition and end of class/interface definition _must not_ be used.
* All interfaces should be fully documented according to established documentation standards.
* Parentheses _must_ always be included calling class constructors with no arguments.

===== Namespaces and imports

* There _must_ be only one blank line after the `namespace` declaration.
* There _must_ be only one blank line after the block of `use` declarations.
* `use` declarations _must_ go after the `namespace` declaration.
* There _must_ be only one `use` keyword per declaration.
* Multiple classes _must not_ be specified in a single `use` statement.
* Multiple `use` declarations _must_ be ordered alphabetically ascending.
* Classes/Interfaces with a backslash `\` inside their fully-qualified name _must not_ use their fully-qualified name inside the code.
* Classes/Interfaces without a backslash `\` inside their fully-qualified name (e.g. the built-in PHP classes) _must_ be fully qualified.
* In a file that does not declare a namespace (and is therefore in the global namespace), classes in any namespace other than global _must_ be specified with a "use" statement at the top of the file.
* Leading backslash `\` _must not_ be included, when importing a class with "use".
* When specifying a class name in a string, use its full name including namespace, without leading backslash `\` (consistent with `::class` constant).
* The namespace separator _must_ be in double-quoted strings.
* The namespace separator _must not_ be escaped in single-quoted strings.
* PHP class aliasing _must_ only be done to avoid a name collision.
** If a collision happens, alias both colliding classes by prefixing the next higher portion of the namespace.

===== Constants

* Class/Interface constants _must_ be declared in all-uppercase with underscore separators.
* Visibility _must_ be declared on all constants.
* Constants _must_ be defined using `const` PHP language keyword.
** `define()` _may_ be used when defining a constant conditionally.

===== Properties

* Property names _must_ be declared in lowerCamelCase.
** Acronyms in names _must_ be in all-uppercase.
** Underscores _must not_ be used.
* All properties _must_ be `private`.
** `public` or `protected` accessor ("getter") method _should_ be used to access the property.
* The PHP4-style `var` keyword _must not_ be used to declare a property.
* Only one property _must_ be declared per statement.
* An empty line between end of property definition and start method definition _must_ be used.

===== Methods

* Method names _must_ be declared in lowerCamelCase.
** Acronyms in names _must_ be in all-uppercase.
** Underscores _must not_ be used.
* All methods of classes _must_ specify their visibility: `public`, `protected`, or `private`.
* `abstract` and `final` modifiers _must_ be declared after the visibility.
* `static` modifier _must_ be declared after the visibility and `abstract`/`final`.
* Methods _must_ have PHPDoc, if method signature can not be strictly typed using only PHP (e.g. `resource` type can not be specified as a type hint).
* If a class has a method that overrides a method from a parent class, but doesn't call for that parent method, `@override` PHPDoc _must_ be used.
** PHPDocs _must_ specify all types.
** Interface _must_ always be used for type hinting, unless scalar value is used.
* Class _must not_ be used for type hinting.
* Return type declaration present there _must_ be one space after the colon followed by the type declaration.
* The colon and declaration _must_ be on the same line as the argument list closing parentheses with no spaces between the two characters.
* In nullable type declarations there _must not_ be a space between the question mark and the type.

==== Functions

* Functions names _must_ be declared in lowerCamelCase.
* Space _must not_ be used in function call between the function name, the opening parenthesis, and the first parameter.
* Space _must_ be used between commas and each parameter.
* Space _must not_ be used between the last parameter, the closing parenthesis, and the semicolon.
* Parameters in function calls _must_ be split onto several lines. Each parameter _must_ be placed on a new line.
** Parameters need to be indented 2 spaces compared to the level of the function call.
** The opening parenthesis is to be put at the end of the function call line.
** The closing parenthesis gets its own line at the end of the parameters.
* Arguments with default values _must_ be at the end of the argument list.
* Always attempt to return a meaningful value from a function, if one is appropriate.
* Anonymous functions _must_ have a space between "function" and its parameters.
* Space _must_ be used between the closing parenthesis and open curly bracket.
** Curly bracket _must_ be located on the same line.
* Functions with many parameters that exceed characters limit _must_ be split onto several lines.
** The first parameters _must_ be put onto the same line as the function name if there is enough space.
** Subsequent parameters _must_ be on following lines and indented to the match the first parameter.
** The closing parenthesis and the opening brace are to be put onto the same line as the last parameter.

==== Variables

* Variables names _must_ be declared in lowerCamelCase.
* Global variables _must not_ be used.

==== Closures

* Closures _must_ be declared with a space after the `function` keyword, and a space before and after the `use` keyword.
* The opening brace _must_ go on the same line.
* The closing brace _must_ go on the next line following the body.
* There _must not_ be a space after the opening parenthesis of the argument list or variable list.
* There _must not_ be a space before the closing parenthesis of the argument list or variable list.
* In the argument list and variable list, there _must not_ be a space before each comma.
* In the argument list and variable list, there _must_ be one space after each comma.
* Closure arguments with default values _must_ go at the end of the argument list.
* Argument lists and variable lists _may_ be split across multiple lines, where each subsequent line is indented once.
** The first item in the list _must_ be on the next line.
** There _must_ be only one argument or variable per line.
** The closing parenthesis and opening brace _must_ be placed together on their own line with one space between them.
* Anonymous classes _must_ follow the same guidelines and principles as closures.

==== Traits

* The `use` keyword used inside the classes to implement traits _must_ be declared on the next line after the opening brace.
* Each individual trait that is imported into a class _must_ be included one-per-line
* Each individual trait inclusion _must_ have its own `use` import statement.
* When the class has nothing after the `use` import statement, the class closing brace _must_ be on the next line after the `use` import statement.
* Otherwise it _must_ have a blank line after the `use` import statement.
* Each `insteadof` and `as` statement usage _must_ be on it own line, indented once.
* `insteadof` and `as` keyword _must_ be have a space before and after.

=== Exceptions

Checked exceptions are exceptions which handling is recognized by compiler or static code analysis tools, forcing developer to recognize and handle it.

Unchecked exceptions are exceptions that can not be predicted during the development and static code analysis and may happen at any moment.

Use only checked exceptions of `\Xtuple\Util\Exception\Throwable` type. `\Xtuple\Util\Exception\Throwable` interface provides localizable message and ability to pass multiple errors related to the exception.

Treat unchecked exceptions, specified in other methods (or their documentation) as checked. In this case only really unpredictable runtime exceptions (e.g. running out of memory) would remain unchecked.

`try-catch-finally` block should start (`try`) in the beginning of the method and end (`catch` or `catch-finally`) in the end of it. If there is need to use `try-catch` more than once in the method, it's a sure sign that method is not atomic enough and should be refactored into multiple methods or even classes.

If a called method throws an exception, following rules should be checked and applied (ordered by priority):

. Always add `@throws \Throwable` in unit tests.
. If the cases when exception can be thrown are checked by developer, use `/** @noinspection PhpUnhandledExceptionInspection */` annotation before unsafe method call. It's recommended to provide a short additional comment why `@noinspection` is set.
. If a valid default behavior/value is possible, use `try-catch` to make code execution safe. Provide default value/behavior in the method.
. If method has no valid defaults, use `try-catch` to make code execution safe. Chain and re-throw an exception, providing additional context information. Add `@throw \Throwable` to the method's PHPDoc.
. Add `@throws \Throwable` tag to the method's PHPDoc.
  * Only use `\Throwable`, as an exceptional situation should not rely on any additional parameters for recovery. (Logging can check exact type of exception to log for details, if needed).
  * Use it when the exception is thrown by the parent method call, or when the caller method is a decorator.
  * Use it for existing projects, to allow stricter checks, while saving time on migration.

.Examples of handling exceptions in different situations.
[source]
----
<?php declare(strict_types=1);

use Xtuple\Util\Exception\ChainException;
use Xtuple\Util\Exception\Exception;

final class Exceptional {
  /** @var \DateTimeImmutable */
  private $now;
  /** @var string */
  private $connection;

  public function __construct(string $connection) {
    /** @noinspection PhpUnhandledExceptionInspection - 'now' value is a default argument value */ // <1>
    $this->now = new \DateTimeImmutable('now');
    $this->connection = $connection;
  }

  /** @var null|\PDO */
  private $pdo;

  /**
   * @throws \Throwable // <2>
   * @return \PDO
   */
  public function pdo(): \PDO {
    if ($this->pdo === null) {
      $this->pdo = new \PDO($this->connection);
    }
    return $this->pdo;
  }

  /**
   * @throws \Throwable // <3>
   *
   * @param string $query
   * @param array  $params
   *
   * @return \stdClass
   */
  public function execute(string $query, array $params = []): \stdClass {
    $statement = $this->pdo()->prepare($query);
    if ($statement === false) {
      throw new Exception('Failed to prepare a PDO statement');
    }
    /** @var \PDOStatement $statement */
    if (!$statement->execute($params)) {
      throw new Exception('Failed to execute a PDO statement');
    }
    $result = $statement->fetchObject();
    if ($result === false) {
      throw new Exception('Failed to fetch an object from a PDO statement');
    }
    return $result; // <4>
  }

  public function has(int $id): bool {
    try {
      return (bool) $this->execute('SELECT EXISTS(SELECT 1 FROM example WHERE id = :id) AS result;', [
        ':id' => $id,
      ])->result;
    }
    catch (\Throwable $e) { // <5>
    }
    return false;
  }

  /**
   * @throws \Throwable // <6>
   *
   * @param int $id
   *
   * @return \stdClass
   */
  public function get(int $id): \stdClass {
    try {
      return $this->execute('SELECT * FROM example WHERE id = :id', [':id' => $id]);
    }
    catch (\Throwable $e) { // <7>
      throw new ChainException($e, 'Failed to load object {id}', [
        'id' => $id,
      ]);
    }
  }
}
----
<1> `now` is a default value for `\DateTimeImmutable` class constructor and exception is not expected. If eventually exception happens in production (e.g. due to `$timezone` argument error), it can be analysed and `@noinspection` can be removed, if appropriate; but before that happens, this code can be considered safe.
<2> `\PDO::__construct()` throws a `\PDOException`, which extends `\RuntimeException` and would be considered as unchecked by default. Adding `@throws \Throwable` to force method callers to recognize it. (It's **always** better to catch and re-throw an exception, providing more context information).
<3> In `execute()` method, `prepare()`, `execute()` and `fetchObject()` calls may return error codes, so it throws a checked `\Xtuple\Util\Exception\Throwable` exception, while `pdo()` may throw a `\Throwable`. `\Throwable` is at the top of exception hierarchy, so we use it in PHPDoc.
<4> There is no additional context information that we can provide in this method, so we skip catching and chaining exceptions.
<5> All exceptions are silenced. By application convention false includes cases where the answer could not be determined.
<6> Only `\Xtuple\Util\Exception\ChainException` can be thrown by `get()`, but we specify `\Throwable` as it only matters that this method is unsafe.
<7> `get()` must return an actual row from the database, hence throwing an exception is necessary. The previous exceptions may contain confusing information so the code should do the following:
* chain the exception;
* add a message appropriate to this context;
* store the previous exception for logging.

=== Comments

Comments should be considered a code-smell and a failure to write readable code. Comments should be used only to explain **why** some irregular code was added (e.g. to work around some specific problem), **not what** code is suppose to do.

==== PHPDoc

https://wiki.php.net/rfc/scalar_type_hints_v5[Scalar type hints] and https://wiki.php.net/rfc/return_types[return types declarations] have been introduced in PHP 7. This allows remove substantial amount of PHPDocs used previously to declare types to be removed. PHPDocs should be used for types only to overcome current limitations of PHP (no `throws` keyword, no generics, etc.) to provide as strict typing as possible.

* PHPDocs *must not* be used if information can be provided via PHP itself.
* PHPDocs *must* be used for class properties.
* Fully qualified class name *must not* be used.
* PHP core classes *should* be documented as "fully qualified" (e.g. `\Throwable`).
* PHPDocs for overridden and implemented methods *must* be omitted if method signature hasn't changed.
* PHPDocs *should* be used to specify array element types (*may* be skipped if values are of `mixed` types).
* For nullable type `null` *must* be specified *before* the type (e.g. `null|string`).
* For a specific boolean value (`true` or `false`) this value *must* be used instead of `bool` (e.g. `null|false|string`).

Additional PHPDoc tags should be used:

* `@workaround` - to comment code that deals with issues caused by 3rd-party system.
* `@generic` - to tag a method that has generic (`mixed`) parameter(s) that should be narrowed down in implementations.
* `@override` - to tag a method that has a parent method implementation, but its call is omitted on purpose.

As often PHPDocs are shown collapsed, put the overridden/critical information in the first line.

.PHPDoc custom order example
[source]
----
<?php

interface PHPDocs {
  /**
   * @generic //<1>
   *
   * @param int $j
   *
   * @return mixed
   */
  public function element(int $j);
}

final class PHPDocsExample
  implements PHPDocs {
  /**
   * @throws \Throwable //<2>
   *
   * @param int $i
   *
   * @return void
   */
  public function get(int $i): void {}

  /**
   * @return \stdClass //<3>
   * {@inheritdoc}
   */
  public function element() {}
}
----
<1> `@generic` tag marks that `element()` method can be overridden to narrow its type.
<2> `@throws \Throwable` would be visible while PHPDoc is collapsed, while `@param` and `@return` only duplicate information contained in the method signature.
<3> `@return \stdClass` only overrides generic return type (from `mixed` to `\stdClass`), so the rest of the PHPDoc can be inherited

== Development

=== PHPStorm IDE preferences

http://jetbrains.com/phpstorm[PHPStorm] is the most advanced IDE to work with PHP and is *strongly* recommended to use for development. Using other IDEs or editors is up for a developer, and this section can be used as a reference to achieve same code quality and development productivity results.

==== Editor

===== Inspections

[NOTE]
Inspections can be set for IDE or for the Project only. These settings are recommended to be set for IDE and adjusted for specific projects if required.

* PHP
** Error handling
*** Unhandled exception: `checked`; severity: `Warning`.
** PHPDoc
*** Missing `@throws` tag(s): `checked`; severity: `No highlighting, only fix` (to mitigate https://youtrack.jetbrains.com/issue/WI-41446).

===== Code Style → PHP

[NOTE]
Details of how to configure Code Style in PHPStorm are described in its https://www.jetbrains.com/help/phpstorm/configuring-code-style.html[Confgiring Code Style] documentation.

[IMPORTANT]
Code style can be imported from the `link:https://github.com/xtuple/php-util/blob/master/resources/phpstorm/code-style.xml[resources/phpstorm/code-style.xml]` file.

====== Tabs and Indents

* [ ] Use tab character
* [ ] Use smart tabs
* Tab size: `2`
* Indent: `2`
* Continuation indent: `2`
* [ ] Keep indents on empty lines
* [ ] Indent code in PHP tags

====== Spaces

* Before Parentheses
** [ ] Function declaration parentheses
** [ ] Function call parentheses
** [x] Anonymous function parentheses (?)
** [x] `if` parentheses
** [x] `for` parentheses
** [x] `while` parentheses
** [x] `switch` parentheses
** [x] `catch` parentheses
** [ ] Array initializer parentheses
* Around operators
** [x] Assignment operators (`=`, `+=`, …)
** [x] Logical operators (`&&`, `||`)
** [x] Equality operators (`==`, `!=`)
** [x] Relational operators (`<`, `>`, `<=`, `=>`, `<=>`)
** [x] Bitwise operators (`&`, `|`, `^`)
** [x] Additive operators (`+`, `-`)
** [x] Multiplicative operators (`*`, `/`, `%`, `**`)
** [x] Shift operators (`>>`, `<<`)
** [ ] Unary additive operators (`+`, `-`, `++`, `--`)
** [x] Concatenation (`.`)
** [ ] Object access operator (`->`)
** [ ] Null coalescing operator (`??`)
** [x] Assignment in `declare` statement
* Before left brace
** [x] Class left brace
** [x] Function left brace
** [x] `if` left brace
** [x] `else` left brace
** [x] `for` left brace
** [x] `while` left brace
** [x] `do` left brace
** [x] `switch` left brace
** [x] `try` left brace
** [x] `catch` left brace
** [x] `finally` left brace
* Before keywords
** [x] `else` keyword
** [x] `while` keyword
** [x] `catch` keyword
** [x] `finally` keyword
* Within
** [ ] Brackets
** [ ] Brackets around variable/expression
** [ ] Array initializer parentheses
** [ ] Grouping parentheses
** [ ] Function declaration parentheses
** [ ] Function call parentheses
** [ ] `if` parentheses
** [ ] `for` parentheses
** [ ] `while` parentheses
** [ ] `switch` parentheses
** [ ] `catch` parentheses
** [x] `<?=` and `?>`
* Other
** [ ] Before comma
** [x] After comma
** [ ] Before semicolon
** [x] After semicolon
** [x] After type cast
** [ ] Before colon in return type
** [x] After colon in return type
** [ ] Before unary Not (`!`)
** [ ] After unary Not (`!`)

====== Wrapping and braces

* Hard wrap at `120`
* Wrap on typing `Default: No`
* Visual guides `Default: None`
* Keep when reformatting
** [x] Line breaks (?)
** [x] Comment at first column
** [ ] Control statement in one line
** [ ] Simple methods in one line
* Braces placement
** In namespace _End of line_
** In class declaration _End of line_
** In function declaration _End of line_
** In closure declaration _End of line_
** Other _End of line_
* Extends/implements list _Wrap if long_
** [x] Align when multiline
* Extends/implements keyword _Wrap always_
* Function declaration parameters _Wrap if long_
** [x] Align when multiline
** [ ] New line after `(`
** [ ] Place `)` on a new line
** [x] Keep `)` and `{` on one line
* Function/constructor call arguments _Do not wrap_
** [ ] Align when multiline
** [ ] New line after `(`
** [ ] Place `)` on a new line
** Place `()` for constructor _Always_
* Chained method calls _Do not wrap_
** [x] Align when multiline
** [ ] Place `;` on new line
* `if()` statement
** [ ] New line after `(`
** [ ] Place `)` on new line
** Force braces _Always_
** [x] `else` on new line
** [ ] Special `else if` treatment
* `for()`/`foreach()` statements _Do not wrap_
** [x] Align when multiline
** [ ] New line after `(`
** [ ] Place `)` on new line
** Force braces _Always_
* `while()` statement
** Force braces _Always_
* `do … while()` statement
** Force braces _Always_
** [x] `while` on new line
* `switch` statement
** [x] Indent `case` branches
** [x] Indent `break` from `case`
* `try` statement
** [x] `catch` on new line
** [x] `finally` on new line
* Binary expressions _Do not wrap_
** [ ] Align when multiline
** [ ] Operators sign on next line
** [ ] New line after `(`
** [ ] Place `)` on new line
* Assignment statement _Do not wrap_
** [ ] Assignment sign on next line
** [ ] Align consecutive assignments
* Class field/constant groups
** [ ] Align fields in columns
** [ ] Align constants
* Ternary operation _Chop down if long_
** [ ] Align when multiline
** [x] `?` and `:` signs on next line
* Array initializer _Chop down if long_
** [x] Align when multiline
** [ ] Align key-value pairs
** [x] New line after `(`
** [x] Place `)` on new line
* Modifier list
** [ ] Wrap after modifier list
* Function return type
** [ ] Return type on new line
* Group use _Chop down if long_

====== Blank lines

* Keep Maximum Blank Lines
** In declarations: `0`
** In code: `1`
** Before `}`: `0`
** After `{`: `2`
* Minimum Blank Lines
** Before namespace: `1`
** After namespace: `1`
** Before `use` statements: `1`
** After `use` statements: `1`
** Around class: `1`
** After class header: `0`
** Around field: `0`
** Around method: `1`
** Before method body: `0`
** Around class constants: `0`
** After opening tag: `0`
** After function: `1`
** Before `return` statement: `0`

====== PHPDoc

* [x] Align parameter/property names
* [x] Keep blank lines
* [x] Blank lines around parameters
* [x] Blank line before the first tag
* [x] Align tag comments
* [x] Wrap long lines
* Generated Doc Blocks
** [ ] Use fully-qualified class names

====== Code Conversion

* [x] Convert `true`/`false` constants to _Lower case_
* [x] Convert `null` constant to _Lower case_
* [x] Convert `if`/`elseif` to `elseif`
* Array declaration style:
** [x] Force short declaration style
** [x] Add a comma after last element in multiline array

====== Code Generation

* Variable Naming Style _camelCase_
* Fields Default Visibility _private_
* Comment Code
** [ ] Line comment at first column
*** [x] Add a space at comment start

====== Arrangement

* Grouping rules
** [x] Keep getters and setters together
** [x] Keep dependent methods together _depth-first order_
** [x] Keep overridden methods together _keep order_

==== Language & Frameworks

===== PHP

* PHP language level: `7.1 (const visibility, nullables, multiple exceptions)`
* Analysis (_tab_):
** Call tree analysis depth: `1`
** Unchecked exceptions:
*** `\PHPUnit\Framework\AssertionFailedError`
*** `\SebastianBergmann\RecursionContext\InvalidArgumentException`

== Subpackages

=== Cache

`Xtuple\Util\Cache` package provides interfaces and classes to work cache data. Interface `Xtuple\Util\Cache\Cache` should be used to implement cache itself. Each cache is a set of records `Xtuple\Util\Cache\Record\Record` that are stored and identified by their key `Xtuple\Util\Cache\Key\Key`. `Key` and `Record` are generic types, and concrete implementations may extend them to provide more details. For example, implementation for an SQL database may use key as a string, stored in a column, or as a compound key, stored in multiple columns. In each case an extending interfaces and classes may specify this behavior.

`Xtuple\Util\Cache\Cache` extends `\Serializable` interface. Caches are required to handle serialization correctly, without creation of duplicate set of data.

`Xtuple\Util\Cache\Cache\Memory\MemoryCache` is a basic implementation of a cache that can be used to cache information during a request or for testing purposes. `MemoryCache` uses `static` variables to store data and is not persistent.

[source]
.Using `MemoryCache`
----
use Xtuple\Util\Cache\Cache\Memory\MemoryCache;
use Xtuple\Util\Cache\Key\KeyStruct;
use Xtuple\Util\Cache\Record\RecordStruct;
use Xtuple\Util\Type\DateTime\DateTimeString;

$cache = new MemoryCache('example');
// This record has no expiration date.
$cache->insert(new RecordStruct(new KeyStruct(['user', 1]), 'John Doe'));
// Cache::find() returns null is record is not found.
if ($record = $cache->find(new KeyStruct(['user', 1]))) {
  $record->key()->fields() === ['user', 1];
  $record->value() === 'John Doe';
  $record->expiresAt() === null;
}

// This record expires in 1 hour
$cache->insert(new RecordStruct(new KeyStruct(['user', 1, 'name']), 'John Doe', new DateTimeString('+1 hour')));
// Note: key ['user', 1, 'name'] would override key ['user', 1] in MemoryCache
$cache->find(new KeyStruct(['user', 1])) === null;
$cache->find(new KeyStruct(['user', 1, 'name']))->value() === 'John Doe';

// Records can be removed
$cache->delete(new KeyStruct(['user', 1, 'name'));
$cache->find(new KeyStruct(['user', 1, 'name'])) === null;

// Cache can be cleared completely
$cache->clear();
$cache->isEmpty() === true;
----

=== Collection

`Xtuple\Util\Collection` package provides classes to work with collections of elements. It contains abstract and default implementations for both strictly typed and untyped data. All collections are iterable and countable.

[NOTE]
PHP doesn't allow to use the word `List` as a namespace or a class name, so the term `Sequence` is used instead for the namespace and root interface. All the classes are named using the term `List`.

[NOTE]
PHP doesn't have a default mechanism for object identity, so the `Set` is defined not by elements' identity, but by their key method (similarly to `Map`).

Default implementation class path for any collection type follows the same pattern: `{Abstract Data Type}/{Implementation type}/{Narrowing customization}` (e.g. `Xtuple\Util\Collection\Map\ArrayMap\StrictType\StrictlyTypedArrayMap`).

Strict type abstract collections should be used to have generic collections. Original collection type interfaces should be extended to provide type information in PHPDocs.

Example: defining class to provide `ArrayList<stdClass>` list.

[source]
.ListStdClass.php - interface definition
----
<?php namespace Example\ArrayList;

use Xtuple\Util\Collection\Sequence\Sequence;

/**
 * List<stdClass> <1>
 */
interface ListStdClass
  extends Sequence { <2>
  /**
   * @return \stdClass|null <3>
   *
   * @param int $key
   */
  public function get(int $key);

  /**
   * @return \stdClass|null <4>
   */
  public function current();

  public function name(): string; <5>
}
----
<1> Optional hint in "generic" notation. May be useful for long and complicated data structures.
<2> Extending original list interface `Sequence`.
<3> Overriding `get()` definition, to specify `@return \stdClass|null` instead of `@return mixed|null`.
<4> Overriding `current()` definition, to specify return type. `Sequence::key()` doesn't need to be overridden, as its types are the same for all lists.
<5> Additional methods can be added to this type.

[NOTE]
`@generic` PHPDoc tag is used to mark interface methods that need to be overridden with more specific types.

[source]
.ArrayListStdClass.php - actual class implementation
----
<?php namespace Example\ArrayList;

use Xtuple\Util\Collection\Sequence\ArrayList\StrictType\AbstractStrictlyTypedArrayList;

/**
 * ArrayList<stdClass>
 */
final class ArrayListStdClass
  extends AbstractStrictlyTypedArrayList <1>
  implements ListStdClass { <2>
  /** @var string */
  private $name;
  /**
   * @param \stdClass[] $elements <3>
   * @param string      $name
   */
  public function __construct(array $elements = [], string $name = '') {
    parent::__construct(\stdClass::class, $elements); <4>
    $this->name = $name;
  }

  public function name(): string { <5>
    return $this->name;
  }
}
----
<1> `AbstractStrictlyTypedArrayList` automatically checks elements' types.
<2> Specify implemented interface to reference overridden `get()` and `current()` methods.
<3> Overriding constructor PHPDoc to narrow type hint (`@param \stdClass[] $elements` instead of `@param array $elements`) and hide `$type` parameter
<4> Pass exact type `stdClass` into parent constructor.
<5> Implementation of the additional method defined in `ListStdClass`.

==== List (Sequence)

`Xtuple\Util\Collection\Sequence` package provides default list implementations. List keys are integers and count starts from `0`. List allows access to any existing element with `get(int $key)` method. List is immutable.

[source]
.Example usage of the `ArrayList`.
----
use Xtuple\Util\Collection\Sequence\ArrayList\ArrayList;

// Lists remove all the array keys, and start numeration from 0.
$list = new ArrayList(['one' => 1, 'two' => 2, 'three' => 3]);

// Returns 2, as 'two' is removed.
$list->get(1);
----

[source]
.Example usage of the `StrictlyTypedArrayList`.
----
use Xtuple\Util\Collection\Sequence\ArrayList\StrictType\StrictlyTypedArrayList;

// Effectively, $list is List<Countable>
$list = new StrictlyTypedArrayList(\Countable::class, [
  new \ArrayObject([1]),
  new \ArrayObject([1, 2]),
]);

$list->get(0)->count(); // returns 1

foreach ($list as $k => $value) {
  // \Countable interface methods can be used without a type check, as type is checked on input.
  $value->count();
}
----

==== Map

`Xtuple\Util\Collection\Map` package provides default key-value map implementations. Unlike usual key-value maps, Map keys are always strings (not objects). Map allows access to any existing element with `get(string $key)` method. Map is immutable.

[source]
.Example usage of the `ArrayMap`.
----
use Xtuple\Util\Collection\Map\ArrayMap\ArrayMap;

// Array's default keys are casted to string
$map = new ArrayMap([1, 2 => 'two', 'three' => 3]);

// Note: parameter is string
$map->get('0'); // returns 1
$map->get('1'); // returns null
$map->get('2'); // returns 'two'
$map->get('three'); // returns 3

// Mapping callback can be specified to be used instead of default keys
$map = new ArrayMap([
  ['code' => 'US', 'name' => 'United States'],
  ['code' => 'CA', 'name' => 'Canada'],
], function ($element) {
  return $element['code'];
});

// Returns ['code' => 'US, 'name' => 'United States']
$map->get('US');
----

[source]
.Example usage of the `StrictlyTypedArrayMap`.
----
use Xtuple\Util\Collection\Map\ArrayMap\StrictType\StrictlyTypedArrayMap;

// $map is Map<string, stdClass>
$map = new StrictlyTypedArrayMap(\stdClass::class, [
  'US' => (object) ['code' => 'US', 'name' => 'United States'],
  'CA' => (object) ['code' => 'CA', 'name' => 'Canada'],
]);

// $key parameter can be specified to provide name of the key method. Key method must not require any parameters.
$map = new StrictlyTypedArrayMap(\Countable::class, [
  new \ArrayObject([1]),
  new \ArrayObject([1, 2]),
  new \ArrayObject([2]),
], 'count');

// Returns ArrayObject([1, 2]), as its count() returned 2
$map->get('2');

// Returns ArrayObject([2]), as it overrides earlier provided ArrayObject([1])
$map->get('1');
----

==== Set

`Xtuple\Util\Collection\Set` package provides default set implementation. As PHP doesn't support objects identity by default, its implementation can be chosen by user (two objects may be completely different, but would be considered identical, as long as their key method returns the same value). This effectively makes Set similar to Map, but unlike Map, Set throws exception when duplicates occur. Set is immutable.

[source]
.Example usage of the `ArraySet`.
----
use Xtuple\Util\Collection\Set\ArraySet\ArraySet;

// Array's default keys are casted to string
$map = new ArraySet([1, 2 => 'two', 'three' => 3]);
$map->get('0'); // returns 1
$map->get('1'); // returns null
$map->get('2'); // returns 'two'
$map->get('three'); // returns 3

// Mapping callback can be specified to be used instead of default keys
$map = new ArraySet([
  ['code' => 'US', 'name' => 'United States'],
  ['code' => 'CA', 'name' => 'Canada'],
], function ($element) {
  return $element['code'];
});

// Returns ['code' => 'US, 'name' => 'United States']
$map->get('US');

// Throws an exception, as 'code' => 'US' is duplicated.
$map = new ArraySet([
  ['code' => 'US', 'name' => 'United States'],
  ['code' => 'CA', 'name' => 'Canada'],
  ['code' => 'US', 'name' => 'USA'],
], function ($element) {
  return $element['code'];
});
----

[source]
.Example usage of the `StrictlyTypedArraySet`.
----
use Xtuple\Util\Collection\Set\ArraySet\StrictType\StrictlyTypedArraySet;

final class Country {
  /** @var array */
  private $data;
  public function __construct(array $data) {
    $this->data = $data;
  }
  public function code(): string { return $this->data['code']; }
  public function name(): string { return $this->data['name']; }
}

// $map is Set<Country>
$map = new StrictlyTypedArraySet(Country::class, [
  'US' => new Country(['code' => 'US', 'name' => 'United States']),
  'CA' => new Country(['code' => 'CA', 'name' => 'Canada']),
]);

// $key parameter can be specified to provide name of the key method. Key method must not require any parameters.
$map = new StrictlyTypedArraySet(Country::class, [
  new Country(['code' => 'US', 'name' => 'United States']),
  new Country(['code' => 'CA', 'name' => 'Canada']),
], 'code');

// Returns 'United States'
$map->get('US')->name();

// Throws an exception, as code 'US' is duplicated.
$map = new StrictlyTypedArraySet(Country::class, [
  new Country(['code' => 'US', 'name' => 'United States']),
  new Country(['code' => 'CA', 'name' => 'Canada']),
  new Country(['code' => 'US', 'name' => 'USA']),
], 'code');
----

==== Stack

`Xtuple\Util\Collection\Stack` package provides a default stack implementation. Similarly to List, stack keys are handled internally. Stack is mutable and provides `push()` and `pop()` methods to mutate its state.

[source]
.Example usage of the `ArrayStack`.
----
use Xtuple\Util\Collection\Stack\ArrayStack\ArrayStack;

// Initial state may be provided
$stack = new ArrayStack(['one', 'two']);

// Returns 3 - size of an updated stack
$stack->push('three');

// Returns 'three'
$stack->pop();
----

[source]
.Example usage of the `StrictlyTypedArrayStack`.
----
use Xtuple\Util\Collection\Stack\ArrayStack\StrictType\StrictlyTypedArrayStack;

//
$stack = new StrictlyTypedArrayStack(\stdClass:class, [
  (object) ['value' => 'one'],
  (object) ['value' => 'two'],
]);

// Returns 3 - size of an updated stack
$stack->push(['value' => 'three']);

// Returns 'three'
$stack->pop()->value;

// Throws an exception, as string is passed, not a \stdClass
$stack->push('three');
----

==== Tree

`Xtuple\Util\Collection\Tree` package handles nested data (but not necessarily using tree-representation to do it). `Tree` is mutable and provides `set()` and `remove()` methods to change its state. `Tree::data(): array` method returns all the data as a (nested) array. `Tree` keys may be both strings or integers, but all the specific data is retrieved using key paths to the node. `Tree` is iterable, but should iterate only through the top-level keys and elements (as otherwise it's not clear how to cast nested keys to strings or integers.). Similarly, `Tree::count()` returns the number of top-level data, and `Tree::isEmpty()` doesn't check all the leaves.

As with other `Xtuple\Util\Collection` packages, abstract `Tree` classes may be used implementing new interfaces to provide custom method to access specific keys.

.Using `Xtuple\Util\Collection\Tree\ArrayTree`
[source]
----
use Xtuple\Util\Collection\Tree\ArrayTree\ArrayTree;

$tree = new ArrayTree([
  'name' => 'xtuple/util',
  'require' => [
    'php' => '^7.1',
    'ext-intl' => '*',
    'ext-simplexml' => '*',
    'lib-openssl' => '*',
  ],
]);

// Following is true:
$tree->isEmpty() === false;
$tree->count() === 2;
// Note: get(), set(), remove() require an array of strings and integers.
$tree->get(['name']) === 'xtuple/util';
// set() returns previous value of the (nested) property
$tree->set(['description'], 'xTuple PHP utility classes') === null;
$tree->set(['require', 'php'], '^7.2') === '^7.1';
// remove() returns last value of the (nested) property
$tree->remove(['require', 'lib-openssl']) === '*';
// Final data may be retrieved as array:
$tree->data() === [
  'name' => 'xtuple/util',
  'description' => 'xTuple PHP utility classes',
  'require' => [
    'php' => '^7.2',
    'ext-intl' => '*',
    'ext-simplexml' => '*',
  ],
];
----

=== Enum

`Xtuple\Util\Enum` package provides classes to simplify enums declaration. Using enum classes instead of regular constants allows to have strictly checked types and values. Each type of enum is based on an abstract class that checks available values through reflection. Allowed values should declared as public constants.

==== Bitmask

`Xtuple\Util\Enum\Bitmask\BitmaskEnum` should be used for bit masks. It strictly checks for the bit mask to have all flags possible.

[source]
----
use Xtuple\Util\Enum\Bitmask\BitmaskEnum;

final class Access
  extends BitmaskEnum {
  // Combination as the flags must allow to have all flags up (e.g. 0b111 in this example)
  public const READ = 0b001;
  public const WRITE = 0b010;
  public const EXECUTE = 0b100;

  // A shortcut static constructor for each custom value is possible
  public static function DEFAULT(): Access {
    return new self(self::READ | self::WRITE);
  }

  // A value check shortcut for each basic or custom value is possible
  public function isDefault(): bool {
    return $this->is(self::READ | self::WRITE);
  }
}

// Different declarations are possible
$access = new Access(Access::READ | Access::WRITE);
$access = new Access(3);
$access = Access::DEFAULT(); // if a shortcut method provided

// Different value checks are possible
$access->value() === Access::READ | Access::WRITE;
$access->is(3);
$access->isDefault();

// Specific flag check
$access->has(Access::READ) === true;
$access->has(Access::EXECUTE) === false;
----

==== Char

`Xtuple\Util\Enum\Char\StringEnum` should be used to provide a set of string constants.

[source]
----
use Xtuple\Util\Enum\Char\StringEnum;

final class Status
  extends StringEnum {
  // Only declared as constants values are allowed
  public const UNPUBLISHED = 'unpublished';
  public const DRAFT = 'draft';
  public const PUBLISHED = 'published';

  // A shortcut static constructor for each value is recommended
  public static function UNPUBLISHED(): Status {
    return new self(self::UNPUBLISHED);
  }

  // A value check shortcut for each value is recommended
  public function isUnpublished(): bool {
    return $this->is(self::UNPUBLISHED);
  }
}

// These declarations would return the same value (but different objects)
$status = new Status(Status::UNPUBLISHED);
$status = new Status('unpublished');
$status = Status::UNPUBLISHED(); // if a shortcut method provided

// Check for the value
$status->value() === 'unpublished';
$status->is(Status::UNPUBLISHED);
$status->isUnpublished();  // if a shortcut method provided

// Providing wrong value would cause an exception
try {
  // E.g. $row is loaded from a database
  $row = [
    'status' => 'review',
  ];
  $status = new Status($row['status']);
}
catch (\Throwable $e) {
  // Value `review` is not supported...
  $e->getMessage();
}
----

`Xtuple\Util\Enum\Char\OptionalStringEnum` allows to declare a `string` enum with allowed `null` value.

[source]
----
use Xtuple\Util\Enum\Char\OptionalStringEnum;

final class Status
  extends OptionalStringEnum {
  // Only declared as constants values are allowed
  public const UNPUBLISHED = 'unpublished';
  public const PUBLISHED = 'published';

  // A shortcut static constructor for each value is recommended
  public static function UNDEFINED(): Status {
    return new self(null);
  }

  // A value check shortcut for each value is recommended
  public function isUndefined(): bool {
    return $this->is(null);
  }
}

// These declarations would return the same value (but different objects)
$status = new Status(null);
$status = Status::UNDEFINED(); // if a shortcut method provided

// Check for the value
$status->value() === 'null';
$status->is(null);
$status->isUndefined();  // if a shortcut method provided
----

==== Integer

`Xtuple\Util\Enum\Integer\IntegerEnum` should be used to provide a set of integer constants.

[source]
----
use Xtuple\Util\Enum\Integer\IntegerEnum;

final class Status
  extends IntegerEnum {
  // Only declared as constants values are allowed
  public const UNPUBLISHED = 0;
  public const DRAFT = 1;
  public const PUBLISHED = 2;

  // A shortcut static constructor for each value is recommended
  public static function UNPUBLISHED(): Status {
    return new self(self::UNPUBLISHED);
  }

  // A value check shortcut for each value is recommended
  public function isUnpublished(): bool {
    return $this->is(self::UNPUBLISHED);
  }
}

// These declarations would return the same value (but different objects)
$status = new Status(Status::UNPUBLISHED);
$status = new Status(0);
$status = Status::UNPUBLISHED(); // if a shortcut method provided

// Check for the value
$status->value() === 0;
$status->is(Status::UNPUBLISHED);
$status->isUnpublished();  // if a shortcut method provided

// Providing wrong value would cause an exception
try {
  // E.g. $row is loaded from a database
  $row = [
    'status' => 3,
  ];
  $status = new Status($row['status']);
}
catch (\Throwable $e) {
  // Value `3` is not supported...
  $e->getMessage();
}
----

=== Exception

`Xtuple\Util\Exception` package provides a set of classes to throw translatable exceptions.

`Xtuple\Util\Exception\Throwable` is the base interface for all exceptions, and `Xtuple\Util\Exception\AbstractThrowable` is the base abstract class for all the exceptions. Unlike other packages, this package is not using decorators for abstract classes. Instead, `Xtuple\Util\Exception\AbstractThrowable` extends `\Exception` to utilize the default implementation of the `\Throwable` interface (3rd party PHP code usually catches `\Exception`, not `\Throwable`). All the implementations of `Xtuple\Util\Exception\AbstractThrowable` represent different shortcuts of its constructor.

`Xtuple\Util\Exception\Throwable` provides three methods:

* `message(): \Xtuple\Util\Type\String\Message\Message\Message` - translatable exception message.
* `exceptions(): \Xtuple\Util\Exception\Collection\Sequence\ListThrowable` - list of all previous exceptions, starting with the original exception.
* `errors(): \Xtuple\Util\Type\String\Message\Message\Collection\Sequence\ListMessage` - list of error messages, collection for the exception. This allows to throw one "final" exception for all occured issues (e.g. all errors from multiple async HTTP requests).

`Xtuple\Util\Exception\AbstractThrowable` provides final implementations for all these methods, and also overrides the default `__toString()`, to return information about all previous exceptions and all error messages inside them, instead of the stack trace for the exception.

==== Exception

`Xtuple\Util\Exception\ExceptionWithMessage` is a default implementation of `Xtuple\Util\Exception\AbstractThrowable`, without any constructor customizations. It may be especially helpful, when all the parameters are already provided in the required types.

[source]
----
use Xtuple\Util\Exception\ExceptionWithMessage;
use Xtuple\Util\Type\String\Message\Argument\Collection\Set\ArraySetArgument;
use Xtuple\Util\Type\String\Message\Message\MessageStruct;
use Xtuple\Util\Type\String\Message\Type\Number\Integer\IntegerArgument;
use Xtuple\Util\Type\String\Message\Type\String\StringArgument;

// $message might be returned from HTTP client
$message = new MessageStruct('HTTP error {code}: {message}', new ArraySetArgument([
  new IntegerArgument('code', 404),
  new StringArgument('message', 'Page not found'),
]));

throw new ExceptionWithMessage($message);
----

`Xtuple\Util\Exception\ExceptionWithArguments` is a shortcut for `Xtuple\Util\Exception\ExceptionWithMessage`, that encapsulates `Xtuple\Util\Type\String\Message\Message\MessageStruct`. It's useful, when non-string arguments are required.

[source]
----
use Xtuple\Util\Exception\ExceptionWithArguments;
use Xtuple\Util\Type\String\Message\Argument\Collection\Set\ArraySetArgument;
use Xtuple\Util\Type\String\Message\Type\Number\Integer\IntegerArgument;
use Xtuple\Util\Type\String\Message\Type\String\StringArgument;

throw new ExceptionWithMessage('HTTP error {code}: {message}', new ArraySetArgument([
  new IntegerArgument('code', 404),
  new StringArgument('message', 'Page not found'),
]));
----

`Xtuple\Util\Exception\Exception` is a shortcut for `Xtuple\Util\Exception\ExceptionWithMessage`, that encapsulates `Xtuple\Util\Type\String\Message\Message\MessageWithTokens` (as it's the most commonly used variant and requires the simplest form). All passed parameters are treated as string arguments (by `Xtuple\Util\Type\String\Message\Message\MessageWithTokens`).

[source]
----
use Xtuple\Util\Exception\Exception;

throw new Exception('HTTP error {code}: {message}', [
  'code' => 404, // this parameter would be cast to string and can't be localized as an integer later
  'message' => 'Page not found',
]));
----

==== ChainException

`Xtuple\Util\Exception\ChainException` is a shortcut for `Xtuple\Util\Exception\Exception` when a previous exception should be re-thrown.

[source]
----
use Xtuple\Util\Exception\ChainException;
use Xtuple\Util\Exception\Exception;

try {
  throw new Exception('HTTP error {code}: {message}', [
    'code' => 404,
    'message' => 'Page not found',
  ]));
}
catch (\Throwable $e) {
  throw new ChainException($e, 'API request {request} failed', [
    'request' => 'api/v2/address',
  ]);
}
----

==== MultiErrorException

`Xtuple\Util\Exception\MultiErrorException` is a shortcut for `Xtuple\Util\Exception\Exception` when an exception with multiple errors should be thrown.

[source]
----
use Xtuple\Util\Exception\MultiErrorException;
use Xtuple\Util\Type\String\Message\Type\String\StringMessage;

// See https://secure.php.net/manual/en/function.curl-multi-strerror.php
$ch1 = curl_init('http://example.com/');
$ch2 = curl_init('http://php.net/');
$mh = curl_multi_init();
curl_multi_add_handle($mh, $ch1);
curl_multi_add_handle($mh, $ch2);
$errors = [];
do {
  $status = curl_multi_exec($mh, $active);
  if ($status > 0) {
    $errors[] = new StringMessage(curl_multi_strerror($status));
  }
} while ($status === CURLM_CALL_MULTI_PERFORM || $active);

if (!empty($errors)) {
  // Allow to log/process all occured errors, instead of throwing an exception after the first one has occured.
  throw new MultiErrorException($errors, 'HTTP requests failed');
}
----

=== File

==== Path

`Xtuple\Util\File\Path` package wraps path-related PHP functions into objects. Use `Path` to require interface, instead of using plain string to pass paths around. `Path` object represents only path, and may exist or does not exists, and should check for path status on each call.

[source]
----
use Xtuple\Util\File\Path\PathString;

$path = new PathString('/tmp/path-example');

// Returns false
$path->exists();

// Returns null as path doesn't exist
$path->absolute();

// Returns false
$path->isFile();

// Returns false
$path->isDir();

// Initializing file
touch('/tmp/path-example');

// Returns true
$path->exists();

// Returns "/tmp/path-example"
$path->absolute();

// Returns true
$path->isFile();
----

=== Generics

`Xtuple\Util\Generics` package simplifies work with generic classes.

==== Type

`Xtuple\Util\Generics\Type` package should be used when type check is required.

Use `StrictType` when instance of a class/interface is required, and `ScalarType` when a scalar (string, integer, float or boolean) is required.

[source]
----
use Xtuple\Util\Generics\Type\ScalarType;
use Xtuple\Util\Generics\Type\StrictType;

// Super types may be used.
$type = new StrictType(\Countable::class);

// Type::cast() method returns the same object instance as it receives, if type is correct.
$array1 = new \ArrayObject();
// Passes correctly, as \ArrayObject implements \Countable
$array2 = $type->cast($array1); // ($array1 === $array2)

// Throws an exception, as an array is passed
$type->cast([]);

// Throws an exception, as \stdClass does not implement \Countable;
$type->cast(new \stdClass());

$scalar = new ScalarType();

// Returns 1
$scalar->cast(1);

// Throws an exception, null is not a scalar.
$scalar->cast(null);
----

Use `NullableType` when instance of a class/interface or `null` can be passed, and `NullableScalarType` when a scalar or `null` can be passed.

[source]
----
use Xtuple\Util\Generics\Type\NullableScalarType;
use Xtuple\Util\Generics\Type\NullableType;

// Class/interface names may be passed as strings.
$nullableType = new NullableType('\stdClass'); <1>

// Returns null, instead of throwing an exception (unlike StrictType)
$nullableType->cast(null);

$nullableScalar = new NullabaleScalarType();

// Returns null, instead of throwin an exception
$nullalbeScalar->cast(null);
----
<1> `::class` constant doesn't have a leading root namespace `\`, but it's recommended to provide one when it's passed as a string.

=== RegEx

`Xtuple\Util\RegEx` package allows to handle regular expressions as object, wrapping up PHP https://secure.php.net/manual/en/ref.pcre.php[PCRE functions]. This allows to type hint parameter as a regex and to use named regex classes, which would improve code readability and simplify testing.

.Using `Xtuple\Util\RegEx` package.
[source]
----
use Xtuple\Util\RegEx\AbstractRegExPattern;
use Xtuple\Util\RegEx\RegExPattern;

// Defining a class for a specific pattern.
final class CloudDomainRegEx
  extends AbstractRegExPattern {
  public function __construct() {
    // Pattern to parse cloud EC2-like IPv4 domains
    parent::__construct(new RegExPattern('/
       (?:(\w+)\-)?                                        # prefix
       (?P<ip>
         (?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9])?\-){3} # first 3 parts of IP
         (?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9])           # last part of IP
       )
       \.(.*)                                              # base domain
     /x'));
  }
}

$regex = new CloudDomainRegEx();
// RegEx implements __toString()
(string) $regex === $regex->pattern();

$domain = 'ec2-255-249-199-99.compute-1.amazonaws.com';
// RegEx::group() returns group value by name or number
$regex->group($domain, 'ip') === '255-249-199-99';
$regex->group($domain, '3') === 'compute-1.amazonaws.com';

// RegEx::matches() wraps up preg_match(), but instead of bitmask flags, uses boolean flag parameter
// $capture === true sets PREG_OFFSET_CAPTURE
$regex->matches($domain, $capture = true) === [
  ['ec2-255-249-199-99.compute-1.amazonaws.com', 0],
  ['ec2', 0],
  ['255-249-199-99', 4],
  ['compute-1.amazonaws.com', 19],
  'ip' => ['255-249-199-99', 4],
];

// RegEx::all() wraps up preg_match_all(), but instead of bitmask flags, uses boolean flag parameters
// $set === true sets PREG_SET_ORDER
// $capture === true sets PREG_OFFSET_CAPTURE
$regex->all($domain, $set = true, $capture = true) === [
  [
    ['ec2-255-249-199-99.compute-1.amazonaws.com', 0],
    ['ec2', 0],
    ['255-249-199-99', 4],
    ['compute-1.amazonaws.com', 19],
    'ip' => ['255-249-199-99', 4],
  ],
];

// RegEx::replace() wraps up preg_replace()
$regex->replace('$2.example.com', $domain) === '255-249-199-99.example.com';
----

=== Type

`Xtuple\Util\Type` package contains subpackages to handle real-world data types.

==== DateTime

`Xtuple\Util\Type\DateTime` package handles dates and time information. It uses PHP core https://secure.php.net/manual/en/book.datetime.php[DateTime] package underneath.

`Xtuple\Util\Type\DateTime\DateTime` represents date and time in UTC. It's serializable and JSON serializable. To format `DateTime` into a custom string use `Xtuple\Util\Type\String\Message\Type\DateTime` package.

`Xtuple\Util\Type\DateTime\Timestamp` represents Unix timestamp.

.Using `Xtuple\Util\Type\DateTime` package
[source]
----
use Xtuple\Util\Type\DateTime\DateTimeString;
use Xtuple\Util\Type\DateTime\DateTimeStruct;

// DateTime information depends on the timezone. Examples are shown for a specific timezone.
$default = ini_get('date.timezone');
ini_set('America/New_York');

// \DateTimeImmutable is used as to handle datetime information. By default server timezone is used.
$date = new DateTimeStruct(new \DateTimeImmutable('Jan 1, 2018'));
// Jan 1, 2018 5am UTC
$date->__toString() === '2018-01-01T05:00:00+00:00';
$date->utc() === '2018-01-01T05:00:00Z';
json_encode($date) === '"2018-01-01T05:00:00.000Z"';

// Timezone information parsed from the date string preceeds explicit timezone
$date = new DateTimeStruct(new \DateTimeImmutable('Jan 1, 2018 PST', new \DateTimeZone('UTC')));
// Jan 1, 2018 8am UTC
$date->utc() === '2018-01-01T08:00:00Z';

// DateTimeString is a shortcut for DateTimeStruct
$date = new DateTimeString('Jan 1, 2018', 'UTC');
(string) $date === '2018-01-01T00:00:00+00:00';

// DateTimeTimestamp is a shortcut to get DateTime from a timestamp.
// Unix timestamp is counted from UTC, so custom timezone can not be specified.
$date = new DateTimeTimestamp(0);
(string) $date === '1970-01-01T00:00:00+00:00';

try {
  // Timestamp must be non-negative
  $date = new DateTimeTimestamp(-1);
}
catch (\Throwable $e) {
  $e->getMessage() === 'Unix timestamp must be non-negative.';
}

$timestamp = new TimestampStruct(0);
$timestamp->seconds() === 0;

$timestamp = new TimestampDateTime(new DateTimeTimestamp(0));
$timestamp->seconds() === 0;

try {
  // Timestamp must be non-negative
  $date = new TimestampStruct(-1);
}
catch (\Throwable $e) {
  $e->getMessage() === 'Unix timestamp must be non-negative.';
}

ini_set($default);
----

==== Measure

`Xtuple\Util\Type\Measure` package handles units of measurement.

`Xtuple\Util\Type\Measure\Unit` is a base interface for a UOM. Each unit must provide a symbol, name, list of synonyms and methods to convert to and from SI unit. Each measurement (e.g. `LengthUnit`) extends `Unit` it to provide additional methods.

===== Length

`Xtuple\Util\Type\Measure\Length\Length` interface is used to handle measurement in length (distance) units (`Xtuple\Util\Type\Measure\Length\Unit\LengthUnit`). `Xtuple\Util\Type\Measure\Length\Unit\Unit\Meter` is a base (SI) unit for length.

`Xtuple\Util\Type\Measure\Length\Unit\Collection\Set\LengthUnits` is a `Set<LengthUnit>` that contains all supported units. `Set<LengthUnit>` is using `LengthUnit::symbol()` as a key. `Xtuple\Util\Type\Measure\Length\Unit\Collection\Set\ArraySetLengthUnit` allow to create any custom set of units with a custom key value. `Set<LengthUnit>` has `find(string $search): LengthUnit` to try find a unit across all synonyms.

.Using `Xtuple\Util\Type\Measure\Length` package
[source]
----
use Xtuple\Util\Type\Measure\Length\Unit\Collection\Set\ArraySetLengthUnit;
use Xtuple\Util\Type\Measure\Length\Unit\Collection\Set\LengthUnits;
use Xtuple\Util\Type\Measure\Length\Unit\Unit\Centimeter;
use Xtuple\Util\Type\Measure\Length\Unit\Unit\Meter;
use Xtuple\Util\Type\Measure\Length\LengthStruct;

// When $unit parameter may be skipped, the base unit (SI unit) is used.
$length = new LengthStruct(3.14);
// Following is true:
$length->value() === 3.14;
$length->unit()->is(new Meter()) === true;
$length->in(new Centimeter())->value() === 314;

$units = new LengthUnits();
// Following is true:
$units->get('m')->is(new Meter()) === true;
$units->get('kg') === null;
$units->find('METRES')->is(new Meter()) === true; // note: find() is case-insensitive.

// Third-party integrations may have custom symbols.
$units = new ArraySetLengthUnit([
  'MTR' => new Meter(),
], true);
// Following is true:
$units->get('mtr')->is(new Meter()) === true;
$units->get('inch') === null;
$units->find('mtr')->is(new Meter()) === true;
// Throws an exception, as "foot" unit is not found
$units->find('foot');
----

=====  Mass

`Xtuple\Util\Type\Measure\Mass\Mass` interface is used to handle measurement in mass (weight) units (`Xtuple\Util\Type\Measure\Mass\Unit\MassUnit`). `Xtuple\Util\Type\Measure\Mass\Unit\Unit\Kilogram` is a base (SI) unit for length.

`Xtuple\Util\Type\Measure\Mass\Unit\Collection\Set\MassUnits` is a `Set<MassUnit>` that contains all supported units. `Set<MassUnit>` is using `MassUnit::symbol()` as a key. `Xtuple\Util\Type\Measure\Mass\Unit\Collection\Set\ArraySetMassUnit` allow to create any custom set of units with a custom key value. `Set<MassUnit>` has `find(string $search): MassUnit` to try find a unit across all synonyms.

.Using `Xtuple\Util\Type\Measure\Mass` package
[source]
----
use Xtuple\Util\Type\Measure\Mass\Unit\Collection\Set\ArraySetMassUnit;
use Xtuple\Util\Type\Measure\Mass\Unit\Collection\Set\MassUnits;
use Xtuple\Util\Type\Measure\Mass\Unit\Unit\Gram;
use Xtuple\Util\Type\Measure\Mass\Unit\Unit\Kilogram;
use Xtuple\Util\Type\Measure\Mass\MassStruct;

// When $unit parameter may be skipped, the base unit (SI unit) is used.
$length = new MassStruct(3.14);
// Following is true:
$length->value() === 3.14;
$length->unit()->is(new Kilogram()) === true;
$length->in(new Gram())->value() === 3140;

$units = new MassUnits();
// Following is true:
$units->get('kg')->is(new Kilogram()) === true;
$units->get('m') === null;
$units->find('KILOS')->is(new Kilogram()) === true; // note: find() is case-insensitive.

// Third-party integrations may have custom symbols.
$units = new ArraySetMassUnit([
  'KGS' => new Kilogram(),
], true);
// Following is true:
$units->get('kgs')->is(new Kilogram()) === true;
$units->get('gram') === null;
$units->find('kgs')->is(new Kilogram()) === true;
// Throws an exception, as "gram" unit is not found
$units->find('gram');
----

==== String

`Xtuple\Util\Type\String\Chars` interface describes default string data. It contains only `__toString(): string` method, as any string data must be easily casted to `string`.

===== Encoding

`Xtuple\Util\Type\String\Encoding` package contains sub-packages to support various string encodings.

`Xtuple\Util\Type\String\Encoding\Base64` is used to represent binary data in ASCII format.

`Xtuple\Util\Type\String\Encoding\Base64\Encode\URLSafe` can be used to encode data that must be safe to pass in the URL. URL safe base64 encoding replaces `+` and `/` characters with `-` and `_`.

`Xtuple\Util\Type\String\Encoding\Base64\Encode\URLSafe\JSON` is a shortcut, to additionally do JSON transformation of the data, before encoding it to base64.

.Using `Xtuple\Util\Type\String\Encoding\Base64` package
[source]
----
use Xtuple\Util\Type\String\Encoding\Base64\Decode\Base64DecodedString;
use Xtuple\Util\Type\String\Encoding\Base64\Decode\Base64DecodedStringFromEncoded;
use Xtuple\Util\Type\String\Encoding\Base64\Encode\Base64EncodedString;
use Xtuple\Util\Type\String\Encoding\Base64\Encode\Base64EncodedStringFromDecoded;
use Xtuple\Util\Type\String\Encoding\Base64\Encode\URLSafe\URLSafeBase64EncodedStringFromString;

// Encoded string is built from decoded stringa and vice versa.
$encoded = new Base64EncodedStringFromDecoded(
  new Base64DecodedString('decoded')
);
$decoded = new Base64DecodedStringFromEncoded($encoded);
// Following is true:
$encoded->__toString() === 'ZGVjb2RlZA==';
$decoded->__toString() === 'decoded';

// Encoding and decoding are lazy by default (performed by __toString())
$failed = new Base64DecodedStringFromEncoded(
  new Base64EncodedString('ŻGVjb2RlZÄ==')
);
// Throws an exception, as input contains characters outside of the base64 alphabet
$failed->__toString();
----

.Using `Xtuple\Util\Type\String\Encoding\HTML` package
[source]
----
use Xtuple\Util\Type\String\Encoding\HTML\Decode\HTMLDecodedString;
use Xtuple\Util\Type\String\Encoding\HTML\Decode\HTMLDecodedStringFromEncoded;
use Xtuple\Util\Type\String\Encoding\HTML\Encode\HTMLEncodedStringFromDecoded;

// By default, default_charset is used.
ini_set('default_charset', 'iso-8859-1');

// To get an encoded string, a decoded source string should be provided.
$original = new HTMLDecodedString('<a href="/">Home\'s page</a>');
$encoded = new HTMLEncodedStringFromDecoded($original);
// Following is true:
$encoded->__toString() === '&lt;a href=&quot;/&quot;&gt;Home\'s page&lt;/a&gt;';
$encoded->charset() === 'iso-8859-1';

$encoded = new HTMLEncodedStringFromDecoded(
  // Custom charset and quotes handling can be provided
  new HTMLDecodedString('<a href="/">Home\'s page</a>', ENT_QUOTES, 'UTF-8')
);
// Note: single quote is replaced with &#039;
$encoded->__toString() === '&lt;a href=&quot;/&quot;&gt;Home&#039;s page&lt;/a&gt;';

// Decoding a string
$decoded = new HTMLDecodedStringFromEncoded($encoded);
$decoded->__toString() === '<a href="/">Home\'s page</a>';
----

===== Transliteration

`Xtuple\Util\Type\String\Transliteration` package provides a basic classes to transform input in non-latin characters to latin. http://php.net/manual/en/book.intl.php[PHP Intl extension] is used to perform transliteration.

`Xtuple\Util\Type\String\Transliteration\Slug` allows to prepare user input to be used in URLs.

.Using `Xtuple\Util\Type\String\Transliteration`
[source]
----
use Xtuple\Util\Type\String\Transliteration\ASCIITransliterationString;
use Xtuple\Util\Type\String\Transliteration\Slug\URLSlugString;

// Transforming text into ASCII characters text
$ascii = new ASCIITransliterationString('Königsberg in Ostpreußen, 1255');
$ascii->__toString() === 'Konigsberg in Ostpreussen, 1255';
$ascii->original() === 'Königsberg in Ostpreußen, 1255';

// Using text in URL
$slug = new URLSlugString('Königsberg_in_Ostpreußen, 1255');
// All non alphanum characters , except underscore ('_') are replaced with '-'. Text is turned to lowercase.
$slug->__toString() === 'konigsberg_in_ostpreussen--1255';
// This include slashes `/`, as they are used to separate parts (slugs) of the URL.
$slug = new URLSlugString('Ostpreußen/Königsberg/1255');
$slug->__toString() === 'ostpreussen-konigsberg-1255';
----

==== Message (Localizable string)

`Xtuple\Util\Type\String\Chars\Message` package provides set of localizable/translatable string classes. Name `Message` was inspired by the underlying http://php.net/manual/en/book.intl.php[PHP Intl extension] terminology (see http://php.net/manual/en/class.messageformatter.php[MessageFormatter class]). PHP `intl` extension wraps up http://site.icu-project.org[ICU - International Components for Unicode] library, which makes localization handling highly reliable.

NOTE: In general, localization and translation are not the same: a text in the same language may require different output for the numbers or dates inside it for different locales. But for convenience, these terms would be used interchangeably in this section of documentation, as any localizable string in this package is also translatable.

`Xtuple\Util\Type\String\Chars\Message\Message\Message` is the base type (interface) that defines requirements for a translatable string:

- `Message::__toString()` must return a string, localized for `en_US.UTF-8` locale.
- `Message::format(string $locale): string` returns a string localized for a custom locale.
- `Message::template(): string` returns a template used for a string. Interpolation delimiters are not strictly specified, for compatibility with other frameworks (e.g. Drupal), but by default curly brackets (`{}`) are used and are strongly recommended to be kept.
- `Message::arguments(): Set<Argument>` returns set of arguments used in the template. Arguments may contain delimiters for compatibility with other frameworks, but by default are not used.

`template()` and `arguments()` methods should be used by translation packages to retrieve original data. Some message subtypes, e.g. `PluralMessage`, define more methods to access other data forms, that may be needed for localization.

`Xtuple\Util\Type\String\Chars\Message\Argument` is a `Message` that is used as an argument for other messages:

- `Argument::key()` returns a key - name of the argument inside the message.

.Using `Xtuple\Util\Type\String\Chars\Message\Message`
[source]
----
use Xtuple\Util\Type\String\Message\Argument\Collection\Set\ArraySetArgument;
use Xtuple\Util\Type\String\Message\Argument\ArgumentFromString;
use Xtuple\Util\Type\String\Message\Argument\ArgumentStruct;
use Xtuple\Util\Type\String\Message\Argument\ArgumentWithTokens;
use Xtuple\Util\Type\String\Message\Message\MessageStruct;
use Xtuple\Util\Type\String\Message\Message\MessageWithTokens;
use Xtuple\Util\Type\String\Message\Type\String\StringArgument;

// Basic declaration of a message. Parameters are wrapped in `{}`, but curly brackets are not used in argument name.
$message = new MessageStruct('Query {query} failed: {message}', new ArraySetArgument([
  new StringArgument('query', 'http://httpbin.org/status/404'),
  new StringArgument('message', 'Page not found'),
]));
// Following is correct:
$message->__toString() === 'Query http://httpbin.org/status/404 failed: Page not found';
$message->template() === 'Query {query} failed: {message}';
$message->arguments()->get('message')->__toString() === 'Page not found';
$message->arguments()->get('{message}') === null;

// MessageWithTokens can be used as a shortcut, if parameters do not need localization
$message = new MessageWithTokens('API request failed: ({code}) {message}', [
  'code' => 1024,
  'message' => 'Access denied',
]);
// Note: in en_US.UTF-8 locale number 1024 should be localized as 1,024 by default, but is treated as a string here.
$message->__toString() === 'API request failed: (1024) Access denied'
// But the message template remains, so it can be translated.
$message->template() === 'API request failed: ({code}) {message}';

// Every Argument by default is just a Message with a key (name). And can have nested localizable arguments.
$argument = new ArgumentStruct('error', new MessageWithTokens('({code}) {message}', [
  'code' => 1024,
  'message' => 'Access denied',
]));
$message = new MessageStruct('API request failed: {error}', new ArraySetArgument([
  $argument,
]));
$message->template() === 'API request failed: {error}';
$message->arguments()->get('error')->template() === '({code}) {message}';

// ArgumentFromString is a shortcut for ArgumentStruct, to unpack MessageStruct parameters
$argument = new ArgumentFromString('error', '({code}) {message}', new ArraySetArguments([
  new StringArgument('code', 1024),
  new StringArgument('message', 'Access denied'),
]));

// ArgumentWithTokens is a shortcut for ArgumentStruct, to use MessageWithTokens.
$argument = new ArgumentWithTokens('error', '({code}) {message}', [
  'code' => 1024,
  'message' => 'Access denied',
]);
----

===== Types

Various types of messages are present in `Xtuple\Util\Type\String\Message\Type`. Each subpackage may declare a custom `Message` subtype and provide abstractions for `Message` and `Argument`. Type subpackages may have even more narrowed down subtypes: for example, `Number` type contains `Currency` subtype, along with other number-related subtypes.

String (`Xtuple\Util\Type\String\Message\Type\String`) is the most basic one, used just to fulfill the strict type requirements of `Set<Argument>` and `Set<Message>`. Example of its usage is provided in the section above.

Examples below provided only for `Message` types, but they can also be used with corresponding `Argument` types.

[NOTE]
`Xtuple\Util\Type\String\Message\Type\DateTime\DateTimeMessage` default implementation currently do not use `php-intl` package, due to the difference between commonly used `date()` formatting options and `\IntlDateFormatter`. This also renders `Message::format($locale)` method redundant, as its parameter doesn't change the output. `DateTimeMessage::timezone(?string $timezone = null)` should be used to render date for the given format in the specified timezone.

.Using `Xtuple\Util\Type\String\Message\Type\DateTime\DateTimeMessage`
[source]
----
use Xtuple\Util\Type\String\Message\Type\DateTime\DateTimeMessageStruct;

$default = ini_get('date.timezone');
ini_set('date.timezone', 'America/New_York');

// DateTime is in UTC, formatter uses system default date.timezone setting
$date = new DateTimeMessageStruct(
  new DateTimeString('2018-01-01T00:00:00Z'),
  'm/d/Y g:ia'
);
// Default output is in UTC
(string) $date === '01/01/2018 12:00am';
// $locale doesn't change the format output
$date->locale('ru_RU') === '01/01/2018 12:00am'; // instead of 01.01.2018 00:00
// Default server timezone is used
$date->timezone() === '12/31/2017 7:00pm';
// Custom timezone is used
$date->timezone('America/Los_Angeles') === '12/31/2017 4:00pm';

ini_set('date.timezone', $default);
----

.Using `Xtuple\Util\Type\String\Message\Type\Number\NumberMessage`
[source]
----
use Xtuple\Util\Type\String\Message\Type\Number\Currency\CurrencyMessage;
use Xtuple\Util\Type\String\Message\Type\Number\Float\FloatMessage;
use Xtuple\Util\Type\String\Message\Type\Number\Integer\IntegerMessage;
use Xtuple\Util\Type\String\Message\Type\Number\Percent\PercentMessage;

$integer = new IntegerMessage(5000);
// __toString() defaults to en_US.UTF-8 locale
$integer->__toString() === '5,000';
$integer->format('ru_RU') === '5 000'; // 5&nbsp;000

$float = new FloatMessage(12345.54321);
$float->__toString() === '12,345.543';
$float->format('ru_RU') === '12 345,543'; // 12&nbsp;345,543

// FloatMessage allows to provide custom format
$float = new FloatMessage(6.54321, '#,#00.000#');
$float->__toString() === '006.5432';

// Note: "," is shifted in this example:
$float = new FloatMessage(123456.54321, '#,#000.000#');
$float->__toString() === '12,3456.5432';

// Note: PercentMessage requires a float value, and 1 is 100%
$percent = new PercentMessage(0.05);
$percent->__toString() === '5%';
$percent->format('ru_RU') === '5 %'; // 5&nbsp;%

$percent = new PercentMessage(5);
$percent->__toString() ===  '500%';

// CurrencyMessage requires currency 3-letter ISO 4217 code
$currency = new CurrencyMessage(5000, 'USD');
$currency->__toString() === '$5,000.00';
$currency->format('ru_RU') === '5 000,00 $'; // 5&nbsp;000,00&nbsp;$

// Note: currency formatted according to locale, not currency itself
$currency = new CurrencyMessage(-5432.1024, 'RUB');
$currency->__toString() === '-RUB5,432.10'; // en_US.UTF-8 locale
$currency->format('ru_RU') === '-5 432,10 руб.'; // -5&nbsp;432,10&nbsp;руб.
----

`Xtuple\Util\Type\String\Message\Type\Plural\PluralMessage` adds methods for `Message` required for correct translation of a text with a plural value.

- `PluralMessage::count(): NumberMessage` - count value is localizable too.
- `PluralMessage::singular(): ?Message` - singular translation is optional (this would depend on the language).
- `PluralMessage::plural(): Message` - is the default value and a fallback message.
- `PluralMessage::plurals(): Set<Argument>` - additional http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html[plural forms] may be provided, including exact values (`=0`, `=1`, etc.)
- `PluralMessage::offset(): ?float` - optional offset for the count value. Usually useful when exact value plurals provided.

.Using `Xtuple\Util\Type\String\Message\Type\Plural`
[source]
----
use Xtuple\Util\Type\String\Message\Argument\Collection\Set\ArraySetArgument;
use Xtuple\Util\Type\String\Message\Type\Number\Currency\CurrencyMessage;
use Xtuple\Util\Type\String\Message\Type\Number\Integer\IntegerMessage;
use Xtuple\Util\Type\String\Message\Type\Plural\PluralMessageStruct;
use Xtuple\Util\Type\String\Message\Type\Plural\PluralMessageFromStrings;
use Xtuple\Util\Type\String\Message\Type\String\StringArgument;
use Xtuple\Util\Type\String\Message\Type\String\StringMessage;

$plural = new PluralMessageStruct(
  new IntegerMessage(4321),
  new StringMessage('{count} users are {status}'),
  new StringMessage('One user is {status}'),
  null,
  new ArraySetArgument([
    new StringArgument('status', 'online'),
  ])
);
// Note: using NumberMessage for $count allows to localize count too.
$plural->__toString() === '4,321 users are online';

// PluralMessageFromStrings can be used, when messages are simple strings
$plural = new PluralMessageFromStrings(0, '{count} items', 'One item', [
  '=0' => 'No items',
]);
// Note: '=0' plural is used when count equals 0
$plural->__toString() === 'No items';

$plural = new PluralMessageFromStrings($count = 2, '{count} items', 'One item', [
  '=0' => 'No items',
], null, $offset = 1);
// Note: $count is 2, but since $offset is 1, the result is shown for $count == 1.
$plural->__toString() === 'One item';
----

`Xtuple\Util\Type\String\Message\Type\Select\SelectMessage` adds methods for `Message` required for correct translation of messages with custom selection rules. The basic example would be a selection of correct pronoun based on user's gender.

- `SelectMessage::value(): string` - actual value, select "option"
- `SelectMessage::default(): Message` - default message, a fallback variant.
- `SelectMessage::options(): Set<Argument>` - messages to select from.

.Using `Xtuple\Util\Type\String\Message\Type\Select`
[source]
----
use Xtuple\Util\Type\String\Message\Argument\Collection\Set\ArraySetArgument;
use Xtuple\Util\Type\String\Message\Type\Select\SelectMessageStruct;
use Xtuple\Util\Type\String\Message\Type\String\StringArgument;
use Xtuple\Util\Type\String\Message\Type\String\StringMessage;

$select = new SelectMessageStruct('other', new StringMessage('Their gender is {gender}'), new ArraySetArgument([
  new StringArgument('m', 'male'),
  new StringArgument('f', 'female'),
]), new ArraySetArgument([
  new StringArgument('gender', 'unknown'),
]));
// Note: 'other' option is not provided, so default message is used.
$select->__toString() === 'Their gender is unknown';
----

==== UUID

`Xtuple\Util\Type\UUID` package allows to generate or handle https://en.wikipedia.org/wiki/Universally_unique_identifier[Universally Unique Identifiers]. Currently only UUID v4 generation is supported. `UUID` package requires OpenSSL library to generate cryptographically strong random UUIDs.

.Using `Xtuple\Util\Type\UUID`
[source]
----
use Xtuple\Util\Type\UUID\OptionalUUIDString;
use Xtuple\Util\Type\UUID\UUIDString;
use Xtuple\Util\Type\UUID\UUIDv4;

$uuid = new UUIDv4(); // <1>
// Returns generated UUID:
$uuid->__toString();
// Returns generated UUID as Uniform Resource Name (URN):
$uuid->urn();
// UUIDs can be checked for equality.
$uuid->equals(new UUIDv4());

// An exception is thrown, if passed string is not a valid UUID
$uuid = new UUIDString((string) $uuid);
// If input may not be a valid UUID, and exception check is undesired, use Optional
$optional = new OptionalUUIDStrong((string) $uuid);
// Returns true, if UUID is valid
$optional->isPresent();
// Returns UUID object, if UUID is valid; returns null otherwise
$optional->value();
----
<1> `UUIDv4` constructor may throw an exception, if OpenSSL library can't generate cryptographically strong random bytes. It's unlikely to happen, but https://secure.php.net/manual/en/function.openssl-random-pseudo-bytes.php["some systems may be broken or old."]

=== XML

`Xtuple\Util\XML` package provides classes to simplify work with XML. http://us3.php.net/manual/en/book.simplexml.php[SimpleXML] PHP extension is used for the XML handling. Unlike `\SimpleXMLElement`, this package has a strict separation between an XML attributes, elements and documents.

==== Attribute

`Xtuple\Util\XML\Attribute\XMLAttribute` interface defines methods required to work with an XML attribute.

`Xtuple\Util\XML\Attribute\XMLAttribute::__toString()` method must generate an output for the attribute in `key="value"` format.

===== Basic implementations

The default implementation is provided by `Xtuple\Util\XML\Attribute\XMLAttributeSimple`, using `\SimpleXMLElement`. Unlike `\SimpleXMLElement`, `XMLAttributeSimple` would always represent an XML attribute and would throw an exception if an XML element is passed.

.Using `Xtuple\Util\XML\Attribute\XMLAttributeSimple`
[source]
----
use Xtuple\Util\XML\Attribute\XMLAttributeSimple;
use Xtuple\Util\XML\Element\XMLElementSimple;

$xml = new \SimpleXMLElement('<Database name="phpunit" debug="true" />');
$simple = new XMLAttributeSimple($xml->attributes()['name']);

// Following is true:
$simple->name() === 'name';
$simple->value() === 'phpunit';
$simple->__toString() === 'name="phpunit"';

// Throws an exception, as $xml is an XML element '<Database name="phpunit" debug="true" />', not an attribute.
$simple = new XMLAttributeSimple($xml);
----

`Xtuple\Util\XML\Attribute\XMLAttributeStruct` is a straight-forward implementation of the `XMLAttribute` interface that may be helpful, when an `XMLAttribute` is required, but underlying data is presented in non-XML format (e.g. to create test stubs).

.Using `Xtuple\Util\XML\Attribute\XMLAttributeStruct`
[source]
----
use Xtuple\Util\XML\Attribute\XMLAttributeStruct;

$struct = new XMLAttributeStruct('name', 'phpunit');

// Following is true:
$struct->name() === 'name';
$struct->value() === 'phpunit';
$struct->__toString() === 'name="phpunit"';
----

To provide a custom `XMLAttribute`, the `Xtuple\Util\XML\Attribute\AbstractXMLAttribute` can be extended. It allows to additionally specify attribute as a string. If "to string" value parameter is omitted, the default behavior is preserved.

.Using `Xtuple\Util\XML\Attribute\AbstractXMLAttribute`
[source]
----
use Xtuple\Util\XML\Attribute\AbstractXMLAttribute;
use Xtuple\Util\XML\Attribute\XMLAttributeStruct;

final class FloatXMLAttribute
  extends AbstractXMLAttribute {
  public function __construct(string $name, float $value) {
    parent::__construct(
      new XMLAttributeStruct($name, $value),
      number_format($toStringValue, 2, '.', '')
    );
  }
}

$float = new FloatXMLAttribute('pi', 3.1415);

// Following is true:
$float->value() === 3.1415;
$float->__toString() === 'pi="3.14"';
----

===== Optional

`Xtuple\Util\XML\Attribute\Optional\OptionalXMLAttribute` can be used in `Xtuple\Util\XML\Attribute\Collection\Map\MapXMLAttribute::getOptional()` to provide a default value for an optional attribute. Optional XML attribute output must be empty.

`Xtuple\Util\XML\Attribute\Optional\OptionalXMLAttributeStruct` is a shortcut to match `Xtuple\Util\XML\Attribute\XMLAttributeStruct` signature.

.Using `Xtuple\Util\XML\Attribute\Optional\OptionalXMLAttribute`
[source]
----
use Xtuple\Util\XML\Attribute\Collection\Map\ArrayMapXMLAttribute;
use Xtuple\Util\XML\Attribute\Optional\OptionalXMLAttributeStruct;
use Xtuple\Util\XML\Attribute\Type\Boolean\XMLAttributeBoolean;

$attributes = new ArrayMapXMLAttribute();
// Following is true:
$attributes->get('test') === null;
$attributes->getOptional(new OptionalXMLAttributeStruct('test'))->value() === null;
$attributes->getOptional(new OptionalXMLAttributeStruct('test', true))->value() === true;

// Note that getOptional() default value is returned only if attribute doesn't exist.
// So for strict types, wrapping is still required.
$attribute = new BooleanOptionalXMLAttribute(
  $attributes->getOptional(new OptionalXMLAttributeStruct('test', false)),
  true
);
// OptionalXMLAttributeStruct is used as the default value, so `true` in BooleanOptionalXMLAttribute is not default.
$attribute->value() === false;

// Note that optional default value is `null`
$attribute = new BooleanOptionalXMLAttribute(
  $attributes->getOptional(new OptionalXMLAttributeStruct('test')),
  true
);
// Now BooleanOptionalXMLAttribute default is used.
$attribute->value() === true
----

===== Strict types

`Xtuple\Util\XML\Attribute\XMLAttribute::value()` method is generic. Its return value may be overridden by the children implementations to return a more specific type.

`Xtuple\Util\XML\Attribute\XMLAttributeStruct` treats provided values the same generic way, returning their value as is, but casting them to a string on output and . This might lead to unexpected behavior on conversion to and from XML. To avoid such issues, strict types should be used.

For example, `Xtuple\Util\XML\Attribute\Type\Boolean\BooleanXMLAttribute` interface re-defines `value()` method to return `bool`.

.Using `Xtuple\Util\XML\Attribute\Type\Boolean\BooleanXMLAttribute`
[source]
----
use Xtuple\Util\XML\Attribute\Type\Boolean\BooleanOptionalXMLAttribute;
use Xtuple\Util\XML\Attribute\Type\Boolean\BooleanRequiredXMLAttribute;
use Xtuple\Util\XML\Attribute\Type\Boolean\XMLAttributeBoolean;
use Xtuple\Util\XML\Attribute\XMLAttributeStruct;
use Xtuple\Util\XML\Element\XMLElementString;

// XMLAttributeStruct does not provide custom handling for the value types. Use custom type classes instead.
$struct = new XMLAttributeStruct('debug', true);

// The value is preserved and output keeps default string cast behavior.
$struct->value() === true;
$struct->__toString() === 'debug="1"';

// If BooleanRequiredXMLAttribute is used later on XML with this attribute, value check would fail:
$element = new XMLElementString('<Database name="phpunit" debug="1" />');
$debug = new BooleanRequiredXMLAttribute($element->attributes()->get('debug'));
// BooleanRequiredXMLAttribute checks if value matches "true", not "1" (check is case-insensitive)
$debug->value() !== true;

// To avoid this, use a strictly typed attribute
$attribute = new XMLAttributeBoolean('debug', true);
$attribute->__toString() === 'debug="true"';
$debug = new BooleanRequiredXMLAttribute($attribute);
$debug->value() === true;

// BooleanOptionalXMLAttribute may be used when an attribute may be missing. It requires to provide a default value.
// Note: XMLAttribute object is still required and must not be null.
$test = new BooleanOptionalXMLAttribute($element->attribute()->get('test'), true);
// As the 'test' attribute is missing, the default value is returned.
$test->value() === true;
----

===== Collection

`Map<XMLAttribute::name(), XMLAttribute>` (`Xtuple\Util\XML\Attribute\Collection\Map\MapXMLAttribute`) is used as a default collection for attributes.

`MapXMLAttribute::__toString()` must return a string in `key1="value1" key2="value2"` format. The order of the attributes output may be changed by implementation.

`MapXMLAttribute::getOptional(XMLAttribute $default): XMLAttribute` returns an XMLAttribute if exists, or the provided default otherwise. Use `getOptional()` instead of `get()` when attribute is not required by the document schema.

.Using `Xtuple\Util\XML\Attribute\Collection\Map\ArrayMapXMLAttribute`
[source]
----
use Xtuple\Util\XML\Attribute\Collection\Map\ArrayMapXMLAttribute;
use Xtuple\Util\XML\Attribute\Optional\OptionalXMLAttributeStruct;
use Xtuple\Util\XML\Attribute\XMLAttributeBoolean;
use Xtuple\Util\XML\Attribute\XMLAttributeStruct;

$attributes = new ArrayMapXMLAttribute([
  new XMLAttributeStruct('database', 'phpunit'),
  new XMLAttributeBoolean('debug', true),
]);

// Following is true:
$attributes->__toString() === 'database="phpunit" debug="true"';
$attributes->get('debug')->value() === true;
$attributes->getOptional(new OptionalXMLAttributeStruct('debug'))->value() === null;
$attributes->count() === 2;
----

==== Document

`Xtuple\Util\XML\Document\XMLDocument` interface is reserved to represent fully formed XML document elements, but is currently not implemented.

==== Element

`Xtuple\Util\XML\Element\XMLElement` interface defines methods required to work with an XML element. Unlike `\SimpleXMLElement`, `XMLElement` does not represent an XML document (that should start with an `<?xml` tag, use `Xtuple\Util\XML\Document\XMLDocument` instead). Implementations of the interface must be able to handle any set of data that can be converted into an XML element (for example, see `Xtuple\Util\XML\Element\XMLElementSequence`).

`XMLElement::__toString()` must return a valid XML element string, trimmed and with no prepended `<?xml` tag (even if the input had it).

===== Basic implementations

The default implementation is provided by `Xtuple\Util\XML\Element\XMLElementSimple`, using `\SimpleXMLElement`.  `XMLElementSimple` throws an exception, if a `\SimpleXMLElement` representing an XML attribute is passed.

.Using `Xtuple\Util\XML\Element\XMLElementSimple`
[source]
----
use Xtuple\Util\XML\Attribute\Optional\OptionalXMLAttributeStruct;
use Xtuple\Util\XML\Element\XMLElementSimple;

$xml = <<<EXAMPLE
  <Configuration environment="dev" debug="true">
    <Database parameter="prefix"></Database>
    <Database parameter="name">phpunit</Database>
    <Parameter name="timezone">America/New_York</Parameter>
    Do not change
  </Configuration>
EXAMPLE;

// Default format. Convenient, if a \SimpleXMLElement was provided
$element = new XMLElementSimple(new \SimpleXMLElement($xml));

// Following is true:
$element->name() === 'Configuration';
$element->value() === 'Do not change';
$element->isEmpty() === false;

$element->attributes()->get('debug')->value() === 'true';
// 'schema' attribute does not exist, but code does not fail with a null-pointer exception.
$element->attributes()->getOptional(new OptionalXMLAttributeStruct('schema'))->value() === null;

$element->children('Parameter')->get(0)->__toString() === '<Parameter name="timezone">America/New_York</Parameter>'
$element->children('Database')->count() === 2;
// Equivalent starting with the root tag:
$element->children('/Configuration/Database')->count() === 2;

// XPath expression may be used to filter children. An empty list returned if no matching elements found.
if ($dbName = $element->children('Database[@parameter="name"]')->get(0)) {
  $dbName->value() === 'phpunit';
}

$simple = new \SimpleXMLElement('<Test name="test" />');
// Throws an exception, as an attribute is passed, even it's also a \SimpleXMLElement object.
new XMLElementSimple($simple->attributes()['name']);
----

`Xtuple\Util\XML\Element\XMLElementString` is a shortcut for `XMLElementSimple` to provide XML as a string instead. As `\SimpleXMLElement` is used, `XMLElementString` throws an exception, if provided string can not be parsed as a valid XML, including situations, when more than one XML root tags exist. It means, that any XML created by `XMLElement` might be parsed by `XMLElementString`.

`Xtuple\Util\XML\Element\XMLElementStruct` can be used to build XML from regular data.

.Using `Xtuple\Util\XML\Element\XMLElementStruct`
[source]
----
use Xtuple\Util\XML\Attribute\Collection\Map\ArrayMapXMLAttribute;
use Xtuple\Util\XML\Attribute\Type\Boolean\XMLAttributeBoolean;
use Xtuple\Util\XML\Attribute\XMLAttributeStruct;
use Xtuple\Util\XML\Element\Collection\Sequence\ArrayListXMLElement;
use Xtuple\Util\XML\Element\XMLElementString;
use Xtuple\Util\XML\Element\XMLElementStruct;

$element = new XMLElementStruct('Setup', 'Value', new ArrayMapXMLAttribute([
  new XMLAttributeStruct('database', 'phpunit'),
  new XMLAttributeBoolean('debug', true),
]), new ArrayListXMLElement([
  new XMLElementString('<Timezone>America/New_York</Timezone>'),
]));

$element->__toString() === '<Setup database="phpunit" debug="true"><Timezone>America/New_York</Timezone>Value</Setup>';
----

`Xtuple\Util\XML\Element\XMLElementSequence` should be used to represent a list (sequence) of XML elements as an XML element. `XMLElementSequence` name, value and attributes are always empty.

.Using `Xtuple\Util\XML\Element\XMLElementSequence`
[source]
----
use Xtuple\Util\XML\Element\Collection\Sequence\ArrayListXMLElement;
use Xtuple\Util\XML\Element\XMLElementSequence;

$element = new XMLElementSequence(new ArrayListXMLElement([
  new XMLElementString('<Name>phpunit</Name>'),
  new XMLElementString('<Debug>true</Debug>'),
  new XMLElementString('<Encoding>UTF-8</Encoding>'),
]));
// The following is true:
$element->name() === '';
$element->value() === '';
$element->attributes()->isEmpty() === true;
$element->isEmpty() === false;
$element->children('Name')->get(0)->value() === 'phpunit';
$element->__toString() === '<Name>phpunit</Name><Debug>true</Debug><Encoding>UTF-8</Encoding>';
----

===== Optional

`Xtuple\Util\XML\Element\Optional\OptionalXMLElement` provides an implementation of an `XMLElement` that returns an empty string, if the tag is empty (a regular implementation, should return an actual empty tag, e.g. `<br/>`).

`Xtuple\Util\XML\Element\Optional\OptionalXMLElementStruct` is a shortcut for `OptionalXMLElement` with the same signature as `XMLElementStruct`.

.Using `Xtuple\Util\XML\Element\Optional\OptionalXMLElement`
[source]
----
use Xtuple\Util\XML\Element\Optional\OptionalXMLElement;
use Xtuple\Util\XML\Element\Optional\OptionalXMLElementStruct;
use Xtuple\Util\XML\Element\XMLElementStruct;

$element = new OptionalXMLElement(new XMLElementStruct('Debug', 'true'));
$element->__toString() === '<Debug>true</Debug>';
$element = new OptionalXMLElement(new XMLElementStruct('Debug'));
$element->__toString() === '';

$element = new OptionalXMLElementStruct('Debug', 'true');
$element->__toString() === '<Debug>true</Debug>';
$element = new OptionalXMLElementStruct('Debug');
$element->__toString() === '';
----

===== Strict types

`Xtuple\Util\XML\Element\XMLElement::value()` is a generic method, that always returns `string`. For example, `Xtuple\Util\XML\Element\Type\BooleanXMLElement::value()` returns strictly `bool` (`true` or `false`). `Xtuple\Util\XML\Element\Type\AbstractTypeXMLElement` can be used to simplify adding new strictly typed XML elements.

.Using `Xtuple\Util\XML\Element\Type\Boolean` package
[source]
----
use Xtuple\Util\XML\Element\Type\Boolean\BooleanXMLElement;
use Xtuple\Util\XML\Element\Type\Boolean\OptionalXMLElementBoolean;
use Xtuple\Util\XML\Element\Type\Boolean\XMLElementBoolean;
use Xtuple\Util\XML\Element\XMLElementString;

$element = new XMLElementString('<Debug>true</Debug>');
$debug = new BooleanXMLElement($element->children('Debug')->get(0));
// Following is true:
$element->children('Debug')->get(0)->value() === 'true';
$debug->value() === true;

$element = new XMLElementBoolean('Debug', true);
$element->value() === 'true';

$element = new OptionalXMLElementBoolean('Debug', null);
$element->value() === '';
----

===== Collection

`Xtuple\Util\XML\Element\Collection\Sequence\ListXMLElement` is a default collection of XML elements and `Xtuple\Util\XML\Element\Collection\Sequence\ArrayListXMLElement` is its default implementation.

`ListXMLElement::__toString()` must return an output of the elements in the same order as they are in the list.

.Using `Xtuple\Util\XML\Element\Collection\Sequence\ListXMLElement`
[source]
----
use Xtuple\Util\XML\Element\Collection\Sequence\ArrayListXMLElement;
use Xtuple\Util\XML\Element\XMLElementString;

$list = new ArrayListXMLElement([
  new XMLElementString('<Debug>true</Debug>'),
  new XMLElementString('<Test>false</Test>'),
]);
$list->__toString() === '<Debug>true</Debug><Test>false</Test>';
----
