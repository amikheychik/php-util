= xTuple Utility package
:toc: left
:toclevels: 3
:icons: font
:source-highlighter: coderay
:source-language: php

== Subpackages

=== Collection

`Xtuple/Util/Collection` package provides classes to work with collections of elements. It contains abstract and default implementations for both strictly typed and untyped data. All collections are iterable and countable.

[NOTE]
PHP doesn't allow to use the word `List` as a namespace or a class name, so the term `Sequence` is used instead for the namespace and root interface. All the classes are named using the term `List`.

[NOTE]
PHP doesn't have a default mechanism for object identity, so the `Set` is defined not by elements' identity, but by their key method (similarly to `Map`).

Default implementation class path for any collection type follows the same pattern: `{Abstract Data Type}/{Implementation type}/{Narrowing customization}` (e.g. `Xtuple/Util/Collection/Map/ArrayMap/StrictType/StrictlyTypedArrayMap`).

Strict type abstract collections should be used to have generic collections. Original collection type interfaces should be extended to provide type information in PHPDocs.

Example: defining class to provide `ArrayList<stdClass>` list.

[source]
.ListStdClass.php - interface definition
----
<?php namespace Example\ArrayList;

use Xtuple\Util\Collection\Sequence\Sequence;

/**
 * List<stdClass> <1>
 */
interface ListStdClass
  extends Sequence { <2>
  /**
   * @return \stdClass|null <3>
   *
   * @param int $key
   */
  public function get(int $key);

  /**
   * @return \stdClass|null <4>
   */
  public function current();

  public function name(): string; <5>
}
----
<1> Optional hint in "generic" notation. May be useful for long and complicated data structures.
<2> Extending original list interface `Sequence`.
<3> Overriding `get()` definition, to specify `@return \stdClass|null` instead of `@return mixed|null`.
<4> Overriding `current()` definition, to specify return type. `Sequence::key()` doesn't need to be overridden, as its types are the same for all lists.
<5> Additional methods can be added to this type.

[NOTE]
`@generic` PHPDoc tag is used to mark interface methods that need to be overridden with more specific types.

[source]
.ArrayListStdClass.php - actual class implementation
----
<?php namespace Example\ArrayList;

use Xtuple\Util\Collection\Sequence\ArrayList\StrictType\AbstractStrictlyTypedArrayList;

/**
 * ArrayList<stdClass>
 */
final class ArrayListStdClass
  extends AbstractStrictlyTypedArrayList <1>
  implements ListStdClass { <2>
  /** @var string */
  private $name;
  /**
   * @param \stdClass[] $elements <3>
   * @param string      $name
   */
  public function __construct(array $elements = [], string $name = '') {
    parent::__construct(\stdClass::class, $elements); <4>
    $this->name = $name;
  }

  public function name(): string { <5>
    return $this->name;
  }
}
----
<1> `AbstractStrictlyTypedArrayList` automatically checks elements' types.
<2> Specify implemented interface to reference overridden `get()` and `current()` methods.
<3> Overriding constructor PHPDoc to narrow type hint (`@param \stdClass[] $elements` instead of `@param array $elements`) and hide `$type` parameter
<4> Pass exact type `stdClass` into parent constructor.
<5> Implementation of the additional method defined in `ListStdClass`.

==== List (Sequence)

`Xtuple/Util/Collection/Sequence` package provides default list implementations. List keys are integers and count starts from `0`. List allows access to any existing element with `get(int $key)` method. List is immutable.

[source]
.Example usage of the `ArrayList`.
----
use Xtuple\Util\Collection\Sequence\ArrayList\ArrayList;

// Lists remove all the array keys, and start numeration from 0.
$list = new ArrayList(['one' => 1, 'two' => 2, 'three' => 3]);

// Returns 2, as 'two' is removed.
$list->get(1);
----

[source]
.Example usage of the `StrictlyTypedArrayList`.
----
use Xtuple\Util\Collection\Sequence\ArrayList\StrictType\StrictlyTypedArrayList;

// Effectively, $list is List<Countable>
$list = new StrictlyTypedArrayList(\Countable::class, [
  new \ArrayObject([1]),
  new \ArrayObject([1, 2]),
]);

$list->get(0)->count(); // returns 1

foreach ($list as $k => $value) {
  // \Countable interface methods can be used without a type check, as type is checked on input.
  $value->count();
}
----

==== Map

`Xtuple/Util/Collection/Map` package provides default key-value map implementations. Unlike usual key-value maps, Map keys are always strings (not objects). Map allows access to any existing element with `get(string $key)` method. Map is immutable.

[source]
.Example usage of the `ArrayMap`.
----
use Xtuple\Util\Collection\Map\ArrayMap\ArrayMap;

// Array's default keys are casted to string
$map = new ArrayMap([1, 2 => 'two', 'three' => 3]);

// Note: parameter is string
$map->get('0'); // returns 1
$map->get('1'); // returns null
$map->get('2'); // returns 'two'
$map->get('three'); // returns 3

// Mapping callback can be specified to be used instead of default keys
$map = new ArrayMap([
  ['code' => 'US', 'name' => 'United States'],
  ['code' => 'CA', 'name' => 'Canada'],
], function ($element) {
  return $element['code'];
});

// Returns ['code' => 'US, 'name' => 'United States']
$map->get('US');
----

[source]
.Example usage of the `StrictlyTypedArrayMap`.
----
use Xtuple\Util\Collection\Map\ArrayMap\StrictType\StrictlyTypedArrayMap;

// $map is Map<string, stdClass>
$map = new StrictlyTypedArrayMap(\stdClass::class, [
  'US' => (object) ['code' => 'US', 'name' => 'United States'],
  'CA' => (object) ['code' => 'CA', 'name' => 'Canada'],
]);

// $key parameter can be specified to provide name of the key method. Key method must not require any parameters.
$map = new StrictlyTypedArrayMap(\Countable::class, [
  new \ArrayObject([1]),
  new \ArrayObject([1, 2]),
  new \ArrayObject([2]),
], 'count');

// Returns ArrayObject([1, 2]), as its count() returned 2
$map->get('2');

// Returns ArrayObject([2]), as it overrides earlier provided ArrayObject([1])
$map->get('1');
----

==== Set

`Xtuple/Util/Collection/Set` package provides default set implementation. As PHP doesn't support objects identity by default, its implementation can be chosen by user (two objects may be completely different, but would be considered identical, as long as their key method returns the same value). This effectively makes Set similar to Map, but unlike Map, Set throws exception when duplicates occur. Set is immutable.

[source]
.Example usage of the `ArraySet`.
----
use Xtuple\Util\Collection\Set\ArraySet\ArraySet;

// Array's default keys are casted to string
$map = new ArraySet([1, 2 => 'two', 'three' => 3]);
$map->get('0'); // returns 1
$map->get('1'); // returns null
$map->get('2'); // returns 'two'
$map->get('three'); // returns 3

// Mapping callback can be specified to be used instead of default keys
$map = new ArraySet([
  ['code' => 'US', 'name' => 'United States'],
  ['code' => 'CA', 'name' => 'Canada'],
], function ($element) {
  return $element['code'];
});

// Returns ['code' => 'US, 'name' => 'United States']
$map->get('US');

// Throws an exception, as 'code' => 'US' is duplicated.
$map = new ArraySet([
  ['code' => 'US', 'name' => 'United States'],
  ['code' => 'CA', 'name' => 'Canada'],
  ['code' => 'US', 'name' => 'USA'],
], function ($element) {
  return $element['code'];
});
----

[source]
.Example usage of the `StrictlyTypedArraySet`.
----
use Xtuple\Util\Collection\Set\ArraySet\StrictType\StrictlyTypedArraySet;

final class Country {
  /** @var array */
  private $data;
  public function __construct(array $data) {
    $this->data = $data;
  }
  public function code(): string { return $this->data['code']; }
  public function name(): string { return $this->data['name']; }
}

// $map is Set<Country>
$map = new StrictlyTypedArraySet(Country::class, [
  'US' => new Country(['code' => 'US', 'name' => 'United States']),
  'CA' => new Country(['code' => 'CA', 'name' => 'Canada']),
]);

// $key parameter can be specified to provide name of the key method. Key method must not require any parameters.
$map = new StrictlyTypedArraySet(Country::class, [
  new Country(['code' => 'US', 'name' => 'United States']),
  new Country(['code' => 'CA', 'name' => 'Canada']),
], 'code');

// Returns 'United States'
$map->get('US')->name();

// Throws an exception, as code 'US' is duplicated.
$map = new StrictlyTypedArraySet(Country::class, [
  new Country(['code' => 'US', 'name' => 'United States']),
  new Country(['code' => 'CA', 'name' => 'Canada']),
  new Country(['code' => 'US', 'name' => 'USA']),
], 'code');
----

==== Stack

`Xtuple/Util/Collection/Stack` package provides a default stack implementation. Similarly to List, stack keys are handled internally. Stack is mutable and provides `push()` and `pop()` methods to mutate its state.

[source]
.Example usage of the `ArrayStack`.
----
use Xtuple\Util\Collection\Stack\ArrayStack\ArrayStack;

// Initial state may be provided
$stack = new ArrayStack(['one', 'two']);

// Returns 3 - size of an updated stack
$stack->push('three');

// Returns 'three'
$stack->pop();
----

[source]
.Example usage of the `StrictlyTypedArrayStack`.
----
use Xtuple\Util\Collection\Stack\ArrayStack\StrictType\StrictlyTypedArrayStack;

//
$stack = new StrictlyTypedArrayStack(\stdClass:class, [
  (object) ['value' => 'one'],
  (object) ['value' => 'two'],
]);

// Returns 3 - size of an updated stack
$stack->push(['value' => 'three']);

// Returns 'three'
$stack->pop()->value;

// Throws an exception, as string is passed, not a \stdClass
$stack->push('three');
----

=== Enum

`Xtuple\Util\Enum` package provides classes to simplify enums declaration. Using enum classes instead of regular constants allows to have strictly checked types and values. Each type of enum is based on an abstract class that checks available values through reflection. Allowed values should declared as public constants.

==== Bitmask

`Xtuple\Util\Enum\Bitmask\BitmaskEnum` should be used for bit masks. It strictly checks for the bit mask to have all flags possible.

[source]
----
use Xtuple\Util\Enum\Bitmask\BitmaskEnum;

final class Access
  extends BitmaskEnum {
  // Combination as the flags must allow to have all flags up (e.g. 0b111 in this example)
  public const READ = 0b001;
  public const WRITE = 0b010;
  public const EXECUTE = 0b100;

  // A shortcut static constructor for each custom value is possible
  public static function DEFAULT(): Access {
    return new self(self::READ | self::WRITE);
  }

  // A value check shortcut for each basic or custom value is possible
  public function isDefault(): bool {
    return $this->is(self::READ | self::WRITE);
  }
}

// Different declarations are possible
$access = new Access(Access::READ | Access::WRITE);
$access = new Access(3);
$access = Access::DEFAULT(); // if a shortcut method provided

// Different value checks are possible
$access->value() === Access::READ | Access::WRITE;
$access->is(3);
$access->isDefault();

// Specific flag check
$access->has(Access::READ) === true;
$access->has(Access::EXECUTE) === false;
----

==== Char

`Xtuple\Util\Enum\Char\StringEnum` should be used to provide a set of string constants.

[source]
----
use Xtuple\Util\Enum\Char\StringEnum;

final class Status
  extends StringEnum {
  // Only declared as constants values are allowed
  public const UNPUBLISHED = 'unpublished';
  public const DRAFT = 'draft';
  public const PUBLISHED = 'published';

  // A shortcut static constructor for each value is recommended
  public static function UNPUBLISHED(): Status {
    return new self(self::UNPUBLISHED);
  }

  // A value check shortcut for each value is recommended
  public function isUnpublished(): bool {
    return $this->is(self::UNPUBLISHED);
  }
}

// These declarations would return the same value (but different objects)
$status = new Status(Status::UNPUBLISHED);
$status = new Status('unpublished');
$status = Status::UNPUBLISHED(); // if a shortcut method provided

// Check for the value
$status->value() === 'unpublished';
$status->is(Status::UNPUBLISHED);
$status->isUnpublished();  // if a shortcut method provided

// Providing wrong value would cause an exception
try {
  // E.g. $row is loaded from a database
  $row = [
    'status' => 'review',
  ];
  $status = new Status($row['status']);
}
catch (\Exception $e) {
  // Value `review` is not supported...
  $e->getMessage();
}
----

`Xtuple\Util\Enum\Char\OptionalStringEnum` allows to declare a `string` enum with allowed `null` value.

[source]
----
use Xtuple\Util\Enum\Char\OptionalStringEnum;

final class Status
  extends OptionalStringEnum {
  // Only declared as constants values are allowed
  public const UNPUBLISHED = 'unpublished';
  public const PUBLISHED = 'published';

  // A shortcut static constructor for each value is recommended
  public static function UNDEFINED(): Status {
    return new self(null);
  }

  // A value check shortcut for each value is recommended
  public function isUndefined(): bool {
    return $this->is(null);
  }
}

// These declarations would return the same value (but different objects)
$status = new Status(null);
$status = Status::UNDEFINED(); // if a shortcut method provided

// Check for the value
$status->value() === 'null';
$status->is(null);
$status->isUndefined();  // if a shortcut method provided
----

==== Integer

`Xtuple\Util\Enum\Integer\IntegerEnum` should be used to provide a set of integer constants.

[source]
----
use Xtuple\Util\Enum\Integer\IntegerEnum;

final class Status
  extends IntegerEnum {
  // Only declared as constants values are allowed
  public const UNPUBLISHED = 0;
  public const DRAFT = 1;
  public const PUBLISHED = 2;

  // A shortcut static constructor for each value is recommended
  public static function UNPUBLISHED(): Status {
    return new self(self::UNPUBLISHED);
  }

  // A value check shortcut for each value is recommended
  public function isUnpublished(): bool {
    return $this->is(self::UNPUBLISHED);
  }
}

// These declarations would return the same value (but different objects)
$status = new Status(Status::UNPUBLISHED);
$status = new Status(0);
$status = Status::UNPUBLISHED(); // if a shortcut method provided

// Check for the value
$status->value() === 0;
$status->is(Status::UNPUBLISHED);
$status->isUnpublished();  // if a shortcut method provided

// Providing wrong value would cause an exception
try {
  // E.g. $row is loaded from a database
  $row = [
    'status' => 3,
  ];
  $status = new Status($row['status']);
}
catch (\Exception $e) {
  // Value `3` is not supported...
  $e->getMessage();
}
----

=== Exception

`Xtuple\Util\Exception` package provides a set of classes to throw translatable exceptions.

`Xtuple\Util\Exception\Throwable` is the base interface for all exceptions, and `Xtuple\Util\Exception\AbstractThrowable` is the base abstract class for all the exceptions. Unlike other packages, this package is not using decorators for abstract classes. Instead, `Xtuple\Util\Exception\AbstractThrowable` extends `\Exception` to utilize the default implementation of the `\Throwable` interface (3rd party PHP code usually catches `\Exception`, not `\Throwable`). All the implementations of `Xtuple\Util\Exception\AbstractThrowable` represent different shortcuts of its constructor.

`Xtuple\Util\Exception\Throwable` provides three methods:

* `message(): \Xtuple\Util\Type\String\Message\Message\Message` - translatable exception message.
* `exceptions(): \Xtuple\Util\Exception\Collection\Sequence\ListThrowable` - list of all previous exceptions, starting with the original exception.
* `errors(): \Xtuple\Util\Type\String\Message\Message\Collection\Sequence\ListMessage` - list of error messages, collection for the exception. This allows to throw one "final" exception for all occured issues (e.g. all errors from multiple async HTTP requests).

`Xtuple\Util\Exception\AbstractThrowable` provides final implementations for all these methods, and also overrides the default `__toString()`, to return information about all previous exceptions and all error messages inside them, instead of the stack trace for the exception.

==== Exception

`Xtuple\Util\Exception\ExceptionWithMessage` is a default implementation of `Xtuple\Util\Exception\AbstractThrowable`, without any constructor customizations. It may be especially helpful, when all the parameters are already provided in the required types.

[source]
----
use Xtuple\Util\Exception\ExceptionWithMessage;
use Xtuple\Util\Type\String\Message\Argument\Collection\Set\ArraySetArgument;
use Xtuple\Util\Type\String\Message\Message\MessageStruct;
use Xtuple\Util\Type\String\Message\Type\Number\Integer\IntegerArgument;
use Xtuple\Util\Type\String\Message\Type\String\StringArgument;

// $message might be returned from HTTP client
$message = new MessageStruct('HTTP error {code}: {message}', new ArraySetArgument([
  new IntegerArgument('code', 404),
  new StringArgument('message', 'Page not found'),
]));

throw new ExceptionWithMessage($message);
----

`Xtuple\Util\Exception\ExceptionWithArguments` is a shortcut for `Xtuple\Util\Exception\ExceptionWithMessage`, that encapsulates `Xtuple\Util\Type\String\Message\Message\MessageStruct`. It's useful, when non-string arguments are required.

[source]
----
use Xtuple\Util\Exception\ExceptionWithArguments;
use Xtuple\Util\Type\String\Message\Argument\Collection\Set\ArraySetArgument;
use Xtuple\Util\Type\String\Message\Type\Number\Integer\IntegerArgument;
use Xtuple\Util\Type\String\Message\Type\String\StringArgument;

throw new ExceptionWithMessage('HTTP error {code}: {message}', new ArraySetArgument([
  new IntegerArgument('code', 404),
  new StringArgument('message', 'Page not found'),
]));
----

`Xtuple\Util\Exception\Exception` is a shortcut for `Xtuple\Util\Exception\ExceptionWithMessage`, that encapsulates `Xtuple\Util\Type\String\Message\Message\MessageWithTokens` (as it's the most commonly used variant and requires the simplest form). All passed parameters are treated as string arguments (by `Xtuple\Util\Type\String\Message\Message\MessageWithTokens`).

[source]
----
use Xtuple\Util\Exception\Exception;

throw new Exception('HTTP error {code}: {message}', [
  'code' => 404, // this parameter would be cast to string and can't be localized as an integer later
  'message' => 'Page not found',
]));
----

==== ChainException

`Xtuple\Util\Exception\ChainException` is a shortcut for `Xtuple\Util\Exception\Exception` when a previous exception should be re-thrown.

[source]
----
use Xtuple\Util\Exception\ChainException;
use Xtuple\Util\Exception\Exception;

try {
  throw new Exception('HTTP error {code}: {message}', [
    'code' => 404,
    'message' => 'Page not found',
  ]));
}
catch (\Exception $e) {
  throw new ChainException($e, 'API request {request} failed', [
    'request' => 'api/v2/address',
  ]);
}
----

==== MultiErrorException

`Xtuple\Util\Exception\MultiErrorException` is a shortcut for `Xtuple\Util\Exception\Exception` when an exception with multiple errors should be thrown.

[source]
----
use Xtuple\Util\Exception\MultiErrorException;
use Xtuple\Util\Type\String\Message\Type\String\StringMessage;

// See https://secure.php.net/manual/en/function.curl-multi-strerror.php
$ch1 = curl_init('http://example.com/');
$ch2 = curl_init('http://php.net/');
$mh = curl_multi_init();
curl_multi_add_handle($mh, $ch1);
curl_multi_add_handle($mh, $ch2);
$errors = [];
do {
  $status = curl_multi_exec($mh, $active);
  if ($status > 0) {
    $errors[] = new StringMessage(curl_multi_strerror($status));
  }
} while ($status === CURLM_CALL_MULTI_PERFORM || $active);

if (!empty($errors)) {
  // Allow to log/process all occured errors, instead of throwing an exception after the first one has occured.
  throw new MultiErrorException($errors, 'HTTP requests failed');
}
----

=== File

==== Path

`Xtuple\Util\File\Path` package wraps path-related PHP functions into objects. Use `Path` to require interface, instead of using plain string to pass paths around. `Path` object represents only path, and may exist or does not exists, and should check for path status on each call.

[source]
----
use Xtuple\Util\File\Path\PathString;

$path = new PathString('/tmp/path-example');

// Returns false
$path->exists();

// Returns null as path doesn't exist
$path->absolute();

// Returns false
$path->isFile();

// Returns false
$path->isDir();

// Initializing file
touch('/tmp/path-example');

// Returns true
$path->exists();

// Returns "/tmp/path-example"
$path->absolute();

// Returns true
$path->isFile();
----

=== Generics

`Xtuple/Util/Generics` package simplifies work with generic classes.

==== Type

`Xtuple/Util/Generics/Type` package should be used when type check is required.

Use `StrictType` when instance of a class/interface is required, and `ScalarType` when a scalar (string, integer, float or boolean) is required.

[source]
----
use Xtuple\Util\Generics\Type\ScalarType;
use Xtuple\Util\Generics\Type\StrictType;

// Super types may be used.
$type = new StrictType(\Countable::class);

// Type::cast() method returns the same object instance as it receives, if type is correct.
$array1 = new \ArrayObject();
// Passes correctly, as \ArrayObject implements \Countable
$array2 = $type->cast($array1); // ($array1 === $array2)

// Throws an exception, as an array is passed
$type->cast([]);

// Throws an exception, as \stdClass does not implement \Countable;
$type->cast(new \stdClass());

$scalar = new ScalarType();

// Returns 1
$scalar->cast(1);

// Throws an exception, null is not a scalar.
$scalar->cast(null);
----

Use `NullableType` when instance of a class/interface or `null` can be passed, and `NullableScalarType` when a scalar or `null` can be passed.

[source]
----
use Xtuple\Util\Generics\Type\NullableScalarType;
use Xtuple\Util\Generics\Type\NullableType;

// Class/interface names may be passed as strings.
$nullableType = new NullableType('\stdClass'); <1>

// Returns null, instead of throwing an exception (unlike StrictType)
$nullableType->cast(null);

$nullableScalar = new NullabaleScalarType();

// Returns null, instead of throwin an exception
$nullalbeScalar->cast(null);
----
<1> `::class` constant doesn't have a leading root namespace `\`, but it's recommended to provide one when it's passed as a string.

=== Type

`Xtuple\Util\Type` package contains subpackages to handle real-world data types.

==== Measure

`Xtuple\Util\Type\Measure` package handles units of measurement.

`Xtuple\Util\Type\Measure\Unit` is a base interface for a UOM. Each unit must provide a symbol, name, list of synonyms and methods to convert to and from SI unit. Each measurement (e.g. `LengthUnit`) extends `Unit` it to provide additional methods.

===== Length

`Xtuple\Util\Type\Measure\Length\Length` interface is used to handle measurement in length (distance) units (`Xtuple\Util\Type\Measure\Length\Unit\LengthUnit`). `Xtuple\Util\Type\Measure\Length\Unit\Unit\Meter` is a base (SI) unit for length.

`Xtuple\Util\Type\Measure\Length\Unit\Collection\Set\LengthUnits` is a `Set<LengthUnit>` that contains all supported units. `Set<LengthUnit>` is using `LengthUnit::symbol()` as a key. `Xtuple\Util\Type\Measure\Length\Unit\Collection\Set\ArraySetLengthUnit` allow to create any custom set of units with a custom key value. `Set<LengthUnit>` has `find(string $search): LengthUnit` to try find a unit across all synonyms.

.Using `Xtuple\Util\Type\Measure\Length` package
[source]
----
use Xtuple\Util\Type\Measure\Length\Unit\Collection\Set\ArraySetLengthUnit;
use Xtuple\Util\Type\Measure\Length\Unit\Collection\Set\LengthUnits;
use Xtuple\Util\Type\Measure\Length\Unit\Unit\Centimeter;
use Xtuple\Util\Type\Measure\Length\Unit\Unit\Meter;
use Xtuple\Util\Type\Measure\Length\LengthStruct;

// When $unit parameter may be skipped, the base unit (SI unit) is used.
$length = new LengthStruct(3.14);
// Following is true:
$length->value() === 3.14;
$length->unit()->is(new Meter()) === true;
$length->in(new Centimeter())->value() === 314;

$units = new LengthUnits();
// Following is true:
$units->get('m')->is(new Meter()) === true;
$units->get('kg') === null;
$units->find('METRES')->is(new Meter()) === true; // note: find() is case-insensitive.

// Third-party integrations may have custom symbols.
$units = new ArraySetLengthUnit([
  'MTR' => new Meter(),
], true);
// Following is true:
$units->get('mtr')->is(new Meter()) === true;
$units->get('inch') === null;
$units->find('mtr')->is(new Meter()) === true;
// Throws an exception, as "foot" unit is not found
$units->find('foot');
----

=====  Mass

`Xtuple\Util\Type\Measure\Mass\Mass` interface is used to handle measurement in mass (weight) units (`Xtuple\Util\Type\Measure\Mass\Unit\MassUnit`). `Xtuple\Util\Type\Measure\Mass\Unit\Unit\Kilogram` is a base (SI) unit for length.

`Xtuple\Util\Type\Measure\Mass\Unit\Collection\Set\MassUnits` is a `Set<MassUnit>` that contains all supported units. `Set<MassUnit>` is using `MassUnit::symbol()` as a key. `Xtuple\Util\Type\Measure\Mass\Unit\Collection\Set\ArraySetMassUnit` allow to create any custom set of units with a custom key value. `Set<MassUnit>` has `find(string $search): MassUnit` to try find a unit across all synonyms.

.Using `Xtuple\Util\Type\Measure\Mass` package
[source]
----
use Xtuple\Util\Type\Measure\Mass\Unit\Collection\Set\ArraySetMassUnit;
use Xtuple\Util\Type\Measure\Mass\Unit\Collection\Set\MassUnits;
use Xtuple\Util\Type\Measure\Mass\Unit\Unit\Gram;
use Xtuple\Util\Type\Measure\Mass\Unit\Unit\Kilogram;
use Xtuple\Util\Type\Measure\Mass\MassStruct;

// When $unit parameter may be skipped, the base unit (SI unit) is used.
$length = new MassStruct(3.14);
// Following is true:
$length->value() === 3.14;
$length->unit()->is(new Kilogram()) === true;
$length->in(new Gram())->value() === 3140;

$units = new MassUnits();
// Following is true:
$units->get('kg')->is(new Kilogram()) === true;
$units->get('m') === null;
$units->find('KILOS')->is(new Kilogram()) === true; // note: find() is case-insensitive.

// Third-party integrations may have custom symbols.
$units = new ArraySetMassUnit([
  'KGS' => new Kilogram(),
], true);
// Following is true:
$units->get('kgs')->is(new Kilogram()) === true;
$units->get('gram') === null;
$units->find('kgs')->is(new Kilogram()) === true;
// Throws an exception, as "gram" unit is not found
$units->find('gram');
----

==== String

`Xtuple\Util\Type\String\Chars` interface describes default string data. It contains only `__toString(): string` method, as any string data must be easily casted to `string`.

===== Encoding

`Xtuple\Util\Type\String\Encoding` package contains sub-packages to support various string encodings.

`Xtuple\Util\Type\String\Encoding\Base64` is used to represent binary data in ASCII format.

`Xtuple\Util\Type\String\Encoding\Base64\Encode\URLSafe` can be used to encode data that must be safe to pass in the URL. URL safe base64 encoding replaces `+` and `/` characters with `-` and `_`.

`Xtuple\Util\Type\String\Encoding\Base64\Encode\URLSafe\JSON` is a shortcut, to additionally do JSON transformation of the data, before encoding it to base64.

.Using `Xtuple\Util\Type\String\Encoding\Base64` package
[source]
----
use Xtuple\Util\Type\String\Encoding\Base64\Decode\Base64DecodedString;
use Xtuple\Util\Type\String\Encoding\Base64\Decode\Base64DecodedStringFromEncoded;
use Xtuple\Util\Type\String\Encoding\Base64\Encode\Base64EncodedString;
use Xtuple\Util\Type\String\Encoding\Base64\Encode\Base64EncodedStringFromDecoded;
use Xtuple\Util\Type\String\Encoding\Base64\Encode\URLSafe\URLSafeBase64EncodedStringFromString;

// Encoded string is built from decoded stringa and vice versa.
$encoded = new Base64EncodedStringFromDecoded(
  new Base64DecodedString('decoded')
);
$decoded = new Base64DecodedStringFromEncoded($encoded);
// Following is true:
$encoded->__toString() === 'ZGVjb2RlZA==';
$decoded->__toString() === 'decoded';

// Encoding and decoding are lazy by default (performed by __toString())
$failed = new Base64DecodedStringFromEncoded(
  new Base64EncodedString('ŻGVjb2RlZÄ==')
);
// Throws an exception, as input contains characters outside of the base64 alphabet
$failed->__toString();
----

.Using `Xtuple\Util\Type\String\Encoding\HTML` package
[source]
----
use Xtuple\Util\Type\String\Encoding\HTML\Decode\HTMLDecodedString;
use Xtuple\Util\Type\String\Encoding\HTML\Decode\HTMLDecodedStringFromEncoded;
use Xtuple\Util\Type\String\Encoding\HTML\Encode\HTMLEncodedStringFromDecoded;

// By default, default_charset is used.
ini_set('default_charset', 'iso-8859-1');

// To get an encoded string, a decoded source string should be provided.
$original = new HTMLDecodedString('<a href="/">Home\'s page</a>');
$encoded = new HTMLEncodedStringFromDecoded($original);
// Following is true:
$encoded->__toString() === '&lt;a href=&quot;/&quot;&gt;Home\'s page&lt;/a&gt;';
$encoded->charset() === 'iso-8859-1';

$encoded = new HTMLEncodedStringFromDecoded(
  // Custom charset and quotes handling can be provided
  new HTMLDecodedString('<a href="/">Home\'s page</a>', ENT_QUOTES, 'UTF-8')
);
// Note: single quote is replaced with &#039;
$encoded->__toString() === '&lt;a href=&quot;/&quot;&gt;Home&#039;s page&lt;/a&gt;';

// Decoding a string
$decoded = new HTMLDecodedStringFromEncoded($encoded);
$decoded->__toString() === '<a href="/">Home\'s page</a>';
----

===== Message

`Xtuple\Util\Type\String\Chars\Message` package provides set of localizable/translatable string classes. 

=== XML

`Xtuple\Util\XML` package provides classes to simplify work with XML. http://us3.php.net/manual/en/book.simplexml.php[SimpleXML] PHP extension is used for the XML handling. Unlike `\SimpleXMLElement`, this package has a strict separation between an XML attributes, elements and documents.

==== Attribute

`Xtuple\Util\XML\Attribute\XMLAttribute` interface defines methods required to work with an XML attribute.

`Xtuple\Util\XML\Attribute\XMLAttribute::__toString()` method must generate an output for the attribute in `key="value"` format.

===== Basic implementations

The default implementation is provided by `Xtuple\Util\XML\Attribute\XMLAttributeSimple`, using `\SimpleXMLElement`. Unlike `\SimpleXMLElement`, `XMLAttributeSimple` would always represent an XML attribute and would throw an exception if an XML element is passed.

.Using `Xtuple\Util\XML\Attribute\XMLAttributeSimple`
[source]
----
use Xtuple\Util\XML\Attribute\XMLAttributeSimple;
use Xtuple\Util\XML\Element\XMLElementSimple;

$xml = new \SimpleXMLElement('<Database name="phpunit" debug="true" />');
$simple = new XMLAttributeSimple($xml->attributes()['name']);

// Following is true:
$simple->name() === 'name';
$simple->value() === 'phpunit';
$simple->__toString() === 'name="phpunit"';

// Throws an exception, as $xml is an XML element '<Database name="phpunit" debug="true" />', not an attribute.
$simple = new XMLAttributeSimple($xml);
----

`Xtuple\Util\XML\Attribute\XMLAttributeStruct` is a straight-forward implementation of the `XMLAttribute` interface that may be helpful, when an `XMLAttribute` is required, but underlying data is presented in non-XML format (e.g. to create test stubs).

.Using `Xtuple\Util\XML\Attribute\XMLAttributeStruct`
[source]
----
use Xtuple\Util\XML\Attribute\XMLAttributeStruct;

$struct = new XMLAttributeStruct('name', 'phpunit');

// Following is true:
$struct->name() === 'name';
$struct->value() === 'phpunit';
$struct->__toString() === 'name="phpunit"';
----

To provide a custom `XMLAttribute`, the `Xtuple\Util\XML\Attribute\AbstractXMLAttribute` can be extended. It allows to additionally specify attribute as a string. If "to string" value parameter is omitted, the default behavior is preserved.

.Using `Xtuple\Util\XML\Attribute\AbstractXMLAttribute`
[source]
----
use Xtuple\Util\XML\Attribute\AbstractXMLAttribute;
use Xtuple\Util\XML\Attribute\XMLAttributeStruct;

final class FloatXMLAttribute
  extends AbstractXMLAttribute {
  public function __construct(string $name, float $value) {
    parent::__construct(
      new XMLAttributeStruct($name, $value),
      number_format($toStringValue, 2, '.', '')
    );
  }
}

$float = new FloatXMLAttribute('pi', 3.1415);

// Following is true:
$float->value() === 3.1415;
$float->__toString() === 'pi="3.14"';
----

===== Optional

`Xtuple\Util\XML\Attribute\Optional\OptionalXMLAttribute` can be used in `Xtuple\Util\XML\Attribute\Collection\Map\MapXMLAttribute::getOptional()` to provide a default value for an optional attribute. Optional XML attribute output must be empty.

`Xtuple\Util\XML\Attribute\Optional\OptionalXMLAttributeStruct` is a shortcut to match `Xtuple\Util\XML\Attribute\XMLAttributeStruct` signature.

.Using `Xtuple\Util\XML\Attribute\Optional\OptionalXMLAttribute`
[source]
----
use Xtuple\Util\XML\Attribute\Collection\Map\ArrayMapXMLAttribute;
use Xtuple\Util\XML\Attribute\Optional\OptionalXMLAttributeStruct;
use Xtuple\Util\XML\Attribute\Type\Boolean\XMLAttributeBoolean;

$attributes = new ArrayMapXMLAttribute();
// Following is true:
$attributes->get('test') === null;
$attributes->getOptional(new OptionalXMLAttributeStruct('test'))->value() === null;
$attributes->getOptional(new OptionalXMLAttributeStruct('test', true))->value() === true;

// Note that getOptional() default value is returned only if attribute doesn't exist.
// So for strict types, wrapping is still required.
$attribute = new BooleanOptionalXMLAttribute(
  $attributes->getOptional(new OptionalXMLAttributeStruct('test', false)),
  true
);
// OptionalXMLAttributeStruct is used as the default value, so `true` in BooleanOptionalXMLAttribute is not default.
$attribute->value() === false;

// Note that optional default value is `null`
$attribute = new BooleanOptionalXMLAttribute(
  $attributes->getOptional(new OptionalXMLAttributeStruct('test')),
  true
);
// Now BooleanOptionalXMLAttribute default is used.
$attribute->value() === true
----

===== Strict types

`Xtuple\Util\XML\Attribute\XMLAttribute::value()` method is generic. Its return value may be overridden by the children implementations to return a more specific type.

`Xtuple\Util\XML\Attribute\XMLAttributeStruct` treats provided values the same generic way, returning their value as is, but casting them to a string on output and . This might lead to unexpected behavior on conversion to and from XML. To avoid such issues, strict types should be used.

For example, `Xtuple\Util\XML\Attribute\Type\Boolean\BooleanXMLAttribute` interface re-defines `value()` method to return `bool`.

.Using `Xtuple\Util\XML\Attribute\Type\Boolean\BooleanXMLAttribute`
[source]
----
use Xtuple\Util\XML\Attribute\Type\Boolean\BooleanOptionalXMLAttribute;
use Xtuple\Util\XML\Attribute\Type\Boolean\BooleanRequiredXMLAttribute;
use Xtuple\Util\XML\Attribute\Type\Boolean\XMLAttributeBoolean;
use Xtuple\Util\XML\Attribute\XMLAttributeStruct;
use Xtuple\Util\XML\Element\XMLElementString;

// XMLAttributeStruct does not provide custom handling for the value types. Use custom type classes instead.
$struct = new XMLAttributeStruct('debug', true);

// The value is preserved and output keeps default string cast behavior.
$struct->value() === true;
$struct->__toString() === 'debug="1"';

// If BooleanRequiredXMLAttribute is used later on XML with this attribute, value check would fail:
$element = new XMLElementString('<Database name="phpunit" debug="1" />');
$debug = new BooleanRequiredXMLAttribute($element->attributes()->get('debug'));
// BooleanRequiredXMLAttribute checks if value matches "true", not "1" (check is case-insensitive)
$debug->value() !== true;

// To avoid this, use a strictly typed attribute
$attribute = new XMLAttributeBoolean('debug', true);
$attribute->__toString() === 'debug="true"';
$debug = new BooleanRequiredXMLAttribute($attribute);
$debug->value() === true;

// BooleanOptionalXMLAttribute may be used when an attribute may be missing. It requires to provide a default value.
// Note: XMLAttribute object is still required and must not be null.
$test = new BooleanOptionalXMLAttribute($element->attribute()->get('test'), true);
// As the 'test' attribute is missing, the default value is returned.
$test->value() === true;
----

===== Collection

`Map<XMLAttribute::name(), XMLAttribute>` (`Xtuple\Util\XML\Attribute\Collection\Map\MapXMLAttribute`) is used as a default collection for attributes.

`MapXMLAttribute::__toString()` must return a string in `key1="value1" key2="value2"` format. The order of the attributes output may be changed by implementation.

`MapXMLAttribute::getOptional(XMLAttribute $default): XMLAttribute` returns an XMLAttribute if exists, or the provided default otherwise. Use `getOptional()` instead of `get()` when attribute is not required by the document schema.

.Using `Xtuple\Util\XML\Attribute\Collection\Map\ArrayMapXMLAttribute`
[source]
----
use Xtuple\Util\XML\Attribute\Collection\Map\ArrayMapXMLAttribute;
use Xtuple\Util\XML\Attribute\Optional\OptionalXMLAttributeStruct;
use Xtuple\Util\XML\Attribute\XMLAttributeBoolean;
use Xtuple\Util\XML\Attribute\XMLAttributeStruct;

$attributes = new ArrayMapXMLAttribute([
  new XMLAttributeStruct('database', 'phpunit'),
  new XMLAttributeBoolean('debug', true),
]);

// Following is true:
$attributes->__toString() === 'database="phpunit" debug="true"';
$attributes->get('debug')->value() === true;
$attributes->getOptional(new OptionalXMLAttributeStruct('debug'))->value() === null;
$attributes->count() === 2;
----

==== Document

`Xtuple\Util\XML\Document\XMLDocument` interface is reserved to represent fully formed XML document elements, but is currently not implemented.

==== Element

`Xtuple\Util\XML\Element\XMLElement` interface defines methods required to work with an XML element. Unlike `\SimpleXMLElement`, `XMLElement` does not represent an XML document (that should start with an `<?xml` tag`, use ``Xtuple\Util\XML\Document\XMLDocument` instead). Implementations of the interface must be able to handle any set of data that can be converted into an XML element (for example, see `Xtuple\Util\XML\Element\XMLElementSequence`).

`XMLElement::__toString()` must return a valid XML element string, trimmed and with no prepended `<?xml` tag (even if the input had it).

===== Basic implementations

The default implementation is provided by `Xtuple\Util\XML\Element\XMLElementSimple`, using `\SimpleXMLElement`.  `XMLElementSimple` throws an exception, if a `\SimpleXMLElement` representing an XML attribute is passed.

.Using `Xtuple\Util\XML\Element\XMLElementSimple`
[source]
----
use Xtuple\Util\XML\Attribute\Optional\OptionalXMLAttributeStruct;
use Xtuple\Util\XML\Element\XMLElementSimple;

$xml = <<<EXAMPLE
  <Configuration environment="dev" debug="true">
    <Database parameter="prefix"></Database>
    <Database parameter="name">phpunit</Database>
    <Parameter name="timezone">America/New_York</Parameter>
    Do not change
  </Configuration>
EXAMPLE;

// Default format. Convenient, if a \SimpleXMLElement was provided
$element = new XMLElementSimple(new \SimpleXMLElement($xml));

// Following is true:
$element->name() === 'Configuration';
$element->value() === 'Do not change';
$element->isEmpty() === false;

$element->attributes()->get('debug')->value() === 'true';
// 'schema' attribute does not exist, but code does not fail with a null-pointer exception.
$element->attributes()->getOptional(new OptionalXMLAttributeStruct('schema'))->value() === null;

$element->children('Parameter')->get(0)->__toString() === '<Parameter name="timezone">America/New_York</Parameter>'
$element->children('Database')->count() === 2;
// Equivalent starting with the root tag:
$element->children('/Configuration/Database')->count() === 2;

// XPath expression may be used to filter children. An empty list returned if no matching elements found.
if ($dbName = $element->children('Database[@parameter="name"]')->get(0)) {
  $dbName->value() === 'phpunit';
}

$simple = new \SimpleXMLElement('<Test name="test" />');
// Throws an exception, as an attribute is passed, even it's also a \SimpleXMLElement object.
new XMLElementSimple($simple->attributes()['name']);
----

`Xtuple\Util\XML\Element\XMLElementString` is a shortcut for `XMLElementSimple` to provide XML as a string instead. As `\SimpleXMLElement` is used, `XMLElementString` throws an exception, if provided string can not be parsed as a valid XML, including situations, when more than one XML root tags exist. It means, that any XML created by `XMLElement` might be parsed by `XMLElementString`.

`Xtuple\Util\XML\Element\XMLElementStruct` can be used to build XML from regular data.

.Using `Xtuple\Util\XML\Element\XMLElementStruct`
[source]
----
use Xtuple\Util\XML\Attribute\Collection\Map\ArrayMapXMLAttribute;
use Xtuple\Util\XML\Attribute\Type\Boolean\XMLAttributeBoolean;
use Xtuple\Util\XML\Attribute\XMLAttributeStruct;
use Xtuple\Util\XML\Element\Collection\Sequence\ArrayListXMLElement;
use Xtuple\Util\XML\Element\XMLElementString;
use Xtuple\Util\XML\Element\XMLElementStruct;

$element = new XMLElementStruct('Setup', 'Value', new ArrayMapXMLAttribute([
  new XMLAttributeStruct('database', 'phpunit'),
  new XMLAttributeBoolean('debug', true),
]), new ArrayListXMLElement([
  new XMLElementString('<Timezone>America/New_York</Timezone>'),
]));

$element->__toString() === '<Setup database="phpunit" debug="true"><Timezone>America/New_York</Timezone>Value</Setup>';
----

`Xtuple\Util\XML\Element\XMLElementSequence` should be used to represent a list (sequence) of XML elements as an XML element. `XMLElementSequence` name, value and attributes are always empty.

.Using `Xtuple\Util\XML\Element\XMLElementSequence`
[source]
----
use Xtuple\Util\XML\Element\Collection\Sequence\ArrayListXMLElement;
use Xtuple\Util\XML\Element\XMLElementSequence;

$element = new XMLElementSequence(new ArrayListXMLElement([
  new XMLElementString('<Name>phpunit</Name>'),
  new XMLElementString('<Debug>true</Debug>'),
  new XMLElementString('<Encoding>UTF-8</Encoding>'),
]));
// The following is true:
$element->name() === '';
$element->value() === '';
$element->attributes()->isEmpty() === true;
$element->isEmpty() === false;
$element->children('Name')->get(0)->value() === 'phpunit';
$element->__toString() === '<Name>phpunit</Name><Debug>true</Debug><Encoding>UTF-8</Encoding>';
----

===== Optional

`Xtuple\Util\XML\Element\Optional\OptionalXMLElement` provides an implementation of an `XMLElement` that returns an empty string, if the tag is empty (a regular implementation, should return an actual empty tag, e.g. `<br/>`).

`Xtuple\Util\XML\Element\Optional\OptionalXMLElementStruct` is a shortcut for `OptionalXMLElement` with the same signature as `XMLElementStruct`.

.Using `Xtuple\Util\XML\Element\Optional\OptionalXMLElement`
[source]
----
use Xtuple\Util\XML\Element\Optional\OptionalXMLElement;
use Xtuple\Util\XML\Element\Optional\OptionalXMLElementStruct;
use Xtuple\Util\XML\Element\XMLElementStruct;

$element = new OptionalXMLElement(new XMLElementStruct('Debug', 'true'));
$element->__toString() === '<Debug>true</Debug>';
$element = new OptionalXMLElement(new XMLElementStruct('Debug'));
$element->__toString() === '';

$element = new OptionalXMLElementStruct('Debug', 'true');
$element->__toString() === '<Debug>true</Debug>';
$element = new OptionalXMLElementStruct('Debug');
$element->__toString() === '';
----

===== Strict types

`Xtuple\Util\XML\Element\XMLElement::value()` is a generic method, that always returns `string`. For example, `Xtuple\Util\XML\Element\Type\BooleanXMLElement::value()` returns strictly `bool` (`true` or `false`). `Xtuple\Util\XML\Element\Type\AbstractTypeXMLElement` can be used to simplify adding new strictly typed XML elements.

.Using `Xtuple\Util\XML\Element\Type\Boolean` package
[source]
----
use Xtuple\Util\XML\Element\Type\Boolean\BooleanXMLElement;
use Xtuple\Util\XML\Element\Type\Boolean\OptionalXMLElementBoolean;
use Xtuple\Util\XML\Element\Type\Boolean\XMLElementBoolean;
use Xtuple\Util\XML\Element\XMLElementString;

$element = new XMLElementString('<Debug>true</Debug>');
$debug = new BooleanXMLElement($element->children('Debug')->get(0));
// Following is true:
$element->children('Debug')->get(0)->value() === 'true';
$debug->value() === true;

$element = new XMLElementBoolean('Debug', true);
$element->value() === 'true';

$element = new OptionalXMLElementBoolean('Debug', null);
$element->value() === '';
----

===== Collection

`Xtuple\Util\XML\Element\Collection\Sequence\ListXMLElement` is a default collection of XML elements and `Xtuple\Util\XML\Element\Collection\Sequence\ArrayListXMLElement` is its default implementation.

`ListXMLElement::__toString()` must return an output of the elements in the same order as they are in the list.

.Using `Xtuple\Util\XML\Element\Collection\Sequence\ListXMLElement`
[source]
----
use Xtuple\Util\XML\Element\Collection\Sequence\ArrayListXMLElement;
use Xtuple\Util\XML\Element\XMLElementString;

$list = new ArrayListXMLElement([
  new XMLElementString('<Debug>true</Debug>'),
  new XMLElementString('<Test>false</Test>'),
]);
$list->__toString() === '<Debug>true</Debug><Test>false</Test>';
----
