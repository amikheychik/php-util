= XML

`Xtuple\Util\XML` package provides classes to simplify work with XML.
link:http://us3.php.net/manual/en/book.simplexml.php[SimpleXML]
PHP extension is used for the XML handling.
Unlike `\SimpleXMLElement`,
this package has a strict separation between an XML attributes, elements and documents.

== Attribute

`Xtuple\Util\XML\Attribute\XMLAttribute` interface defines methods required to work with an XML attribute.

`Xtuple\Util\XML\Attribute\XMLAttribute::__toString()`
method must generate an output for the attribute in `key="value"` format.

=== Basic implementations

The default implementation is provided by `Xtuple\Util\XML\Attribute\XMLAttributeSimple`,
using `\SimpleXMLElement`.
Unlike `\SimpleXMLElement`,
`XMLAttributeSimple` would always represent an XML attribute
and would throw an exception if an XML element is passed.

.Using `Xtuple\Util\XML\Attribute\XMLAttributeSimple`
[source]
----
use Xtuple\Util\XML\Attribute\XMLAttributeSimple;
use Xtuple\Util\XML\Element\XMLElementSimple;

$xml = new \SimpleXMLElement('<Database name="phpunit" debug="true" />');
$simple = new XMLAttributeSimple($xml->attributes()['name']);

// Following is true:
$simple->name() === 'name';
$simple->value() === 'phpunit';
$simple->__toString() === 'name="phpunit"';

// Throws an exception, as $xml is an XML element '<Database name="phpunit" debug="true" />', not an attribute.
$simple = new XMLAttributeSimple($xml);
----

`Xtuple\Util\XML\Attribute\XMLAttributeStruct`
is a straight-forward implementation of the `XMLAttribute` interface that may be helpful,
when an `XMLAttribute` is required,
but underlying data is presented in non-XML format
(e.g. to create test stubs).

.Using `Xtuple\Util\XML\Attribute\XMLAttributeStruct`
[source]
----
use Xtuple\Util\XML\Attribute\XMLAttributeStruct;

$struct = new XMLAttributeStruct('name', 'phpunit');

// Following is true:
$struct->name() === 'name';
$struct->value() === 'phpunit';
$struct->__toString() === 'name="phpunit"';
----

To provide a custom `XMLAttribute`,
the `Xtuple\Util\XML\Attribute\AbstractXMLAttribute` can be extended.
It allows to additionally specify attribute as a string.
If "to string" value parameter is omitted,
the default behavior is preserved.

.Using `Xtuple\Util\XML\Attribute\AbstractXMLAttribute`
[source]
----
use Xtuple\Util\XML\Attribute\AbstractXMLAttribute;
use Xtuple\Util\XML\Attribute\XMLAttributeStruct;

final class FloatXMLAttribute
  extends AbstractXMLAttribute {
  public function __construct(string $name, float $value) {
    parent::__construct(
      new XMLAttributeStruct($name, $value),
      number_format($toStringValue, 2, '.', '')
    );
  }
}

$float = new FloatXMLAttribute('pi', 3.1415);

// Following is true:
$float->value() === 3.1415;
$float->__toString() === 'pi="3.14"';
----

=== Optional

`Xtuple\Util\XML\Attribute\Optional\OptionalXMLAttribute`
can be used in
`Xtuple\Util\XML\Attribute\Collection\Map\MapXMLAttribute::getOptional()`
to provide a default value for an optional attribute.
Optional XML attribute output must be empty.

`Xtuple\Util\XML\Attribute\Optional\OptionalXMLAttributeStruct` is a shortcut to match
`Xtuple\Util\XML\Attribute\XMLAttributeStruct` signature.

.Using `Xtuple\Util\XML\Attribute\Optional\OptionalXMLAttribute`
[source]
----
use Xtuple\Util\XML\Attribute\Collection\Map\ArrayMapXMLAttribute;
use Xtuple\Util\XML\Attribute\Optional\OptionalXMLAttributeStruct;
use Xtuple\Util\XML\Attribute\Type\Boolean\XMLAttributeBoolean;

$attributes = new ArrayMapXMLAttribute();
// Following is true:
$attributes->get('test') === null;
$attributes->getOptional(new OptionalXMLAttributeStruct('test'))->value() === null;
$attributes->getOptional(new OptionalXMLAttributeStruct('test', true))->value() === true;

// Note that getOptional() default value is returned only if attribute doesn't exist.
// So for strict types, wrapping is still required.
$attribute = new BooleanOptionalXMLAttribute(
  $attributes->getOptional(new OptionalXMLAttributeStruct('test', false)),
  true
);
// OptionalXMLAttributeStruct is used as the default value, so `true` in BooleanOptionalXMLAttribute is not default.
$attribute->value() === false;

// Note that optional default value is `null`
$attribute = new BooleanOptionalXMLAttribute(
  $attributes->getOptional(new OptionalXMLAttributeStruct('test')),
  true
);
// Now BooleanOptionalXMLAttribute default is used.
$attribute->value() === true
----

=== Strict types

`Xtuple\Util\XML\Attribute\XMLAttribute::value()` method is generic.
Its return value may be overridden by the children implementations to return a more specific type.

`Xtuple\Util\XML\Attribute\XMLAttributeStruct` treats provided values the same generic way,
returning their value as is, but casting them to a string on output.
This might lead to unexpected behavior on conversion to and from XML.
To avoid such issues, strict types should be used.

For example,
`Xtuple\Util\XML\Attribute\Type\Boolean\BooleanXMLAttribute` interface re-defines `value()` method to return `bool`.

.Using `Xtuple\Util\XML\Attribute\Type\Boolean\BooleanXMLAttribute`
[source]
----
use Xtuple\Util\XML\Attribute\Type\Boolean\BooleanOptionalXMLAttribute;
use Xtuple\Util\XML\Attribute\Type\Boolean\BooleanRequiredXMLAttribute;
use Xtuple\Util\XML\Attribute\Type\Boolean\XMLAttributeBoolean;
use Xtuple\Util\XML\Attribute\XMLAttributeStruct;
use Xtuple\Util\XML\Element\XMLElementString;

// XMLAttributeStruct does not provide custom handling for the value types. Use custom type classes instead.
$struct = new XMLAttributeStruct('debug', true);

// The value is preserved and output keeps default string cast behavior.
$struct->value() === true;
$struct->__toString() === 'debug="1"';

// If BooleanRequiredXMLAttribute is used later on XML with this attribute, value check would fail:
$element = new XMLElementString('<Database name="phpunit" debug="1" />');
$debug = new BooleanRequiredXMLAttribute($element->attributes()->get('debug'));
// BooleanRequiredXMLAttribute checks if value matches "true", not "1" (check is case-insensitive)
$debug->value() !== true;

// To avoid this, use a strictly typed attribute
$attribute = new XMLAttributeBoolean('debug', true);
$attribute->__toString() === 'debug="true"';
$debug = new BooleanRequiredXMLAttribute($attribute);
$debug->value() === true;

// BooleanOptionalXMLAttribute may be used when an attribute may be missing. It requires to provide a default value.
// Note: XMLAttribute object is still required and must not be null.
$test = new BooleanOptionalXMLAttribute($element->attribute()->get('test'), true);
// As the 'test' attribute is missing, the default value is returned.
$test->value() === true;
----

=== Collection

`Map<XMLAttribute::name(), XMLAttribute>` 
(`Xtuple\Util\XML\Attribute\Collection\Map\MapXMLAttribute`)
is used as a default collection for attributes.

`MapXMLAttribute::__toString()` must return a string in `key1="value1" key2="value2"` format.
The order of the attributes output may be changed by implementation.

`MapXMLAttribute::getOptional(XMLAttribute $default): XMLAttribute` returns an XMLAttribute if exists,
or the provided default otherwise.
Use `getOptional()` instead of `get()` when attribute is not required by the document schema.

.Using `Xtuple\Util\XML\Attribute\Collection\Map\ArrayMapXMLAttribute`
[source]
----
use Xtuple\Util\XML\Attribute\Collection\Map\ArrayMapXMLAttribute;
use Xtuple\Util\XML\Attribute\Optional\OptionalXMLAttributeStruct;
use Xtuple\Util\XML\Attribute\XMLAttributeBoolean;
use Xtuple\Util\XML\Attribute\XMLAttributeStruct;

$attributes = new ArrayMapXMLAttribute([
  new XMLAttributeStruct('database', 'phpunit'),
  new XMLAttributeBoolean('debug', true),
]);

// Following is true:
$attributes->__toString() === 'database="phpunit" debug="true"';
$attributes->get('debug')->value() === true;
$attributes->getOptional(new OptionalXMLAttributeStruct('debug'))->value() === null;
$attributes->count() === 2;
----

== Document

`Xtuple\Util\XML\Document\XMLDocument` interface is reserved to represent fully formed XML document elements,
but is currently not implemented.

== Element

`Xtuple\Util\XML\Element\XMLElement` interface defines methods required to work with an XML element.
Unlike `\SimpleXMLElement`,
`XMLElement` does not represent an XML document
(that should start with an `<?xml` tag, use `Xtuple\Util\XML\Document\XMLDocument` instead).
Implementations of the interface must be able to handle any set of data that can be converted into an XML element
(for example, see `Xtuple\Util\XML\Element\XMLElementSequence`).

`XMLElement::__toString()` must return a valid XML element string,
trimmed and with no prepended `<?xml` tag (even if the input had it).

=== Basic implementations

The default implementation is provided by `Xtuple\Util\XML\Element\XMLElementSimple`,
using `\SimpleXMLElement`.
`XMLElementSimple` throws an exception,
if a `\SimpleXMLElement` representing an XML attribute is passed.

.Using `Xtuple\Util\XML\Element\XMLElementSimple`
[source]
----
use Xtuple\Util\XML\Attribute\Optional\OptionalXMLAttributeStruct;
use Xtuple\Util\XML\Element\XMLElementSimple;

$xml = <<<EXAMPLE
  <Configuration environment="dev" debug="true">
    <Database parameter="prefix"></Database>
    <Database parameter="name">phpunit</Database>
    <Parameter name="timezone">America/New_York</Parameter>
    Do not change
  </Configuration>
EXAMPLE;

// Default format. Convenient, if a \SimpleXMLElement was provided
$element = new XMLElementSimple(new \SimpleXMLElement($xml));

// Following is true:
$element->name() === 'Configuration';
$element->value() === 'Do not change';
$element->isEmpty() === false;

$element->attributes()->get('debug')->value() === 'true';
// 'schema' attribute does not exist, but code does not fail with a null-pointer exception.
$element->attributes()->getOptional(new OptionalXMLAttributeStruct('schema'))->value() === null;

$element->children('Parameter')->get(0)->__toString() === '<Parameter name="timezone">America/New_York</Parameter>'
$element->children('Database')->count() === 2;
// Equivalent starting with the root tag:
$element->children('/Configuration/Database')->count() === 2;

// XPath expression may be used to filter children. An empty list returned if no matching elements found.
if ($dbName = $element->children('Database[@parameter="name"]')->get(0)) {
  $dbName->value() === 'phpunit';
}

$simple = new \SimpleXMLElement('<Test name="test" />');
// Throws an exception, as an attribute is passed, even it's also a \SimpleXMLElement object.
new XMLElementSimple($simple->attributes()['name']);
----

`Xtuple\Util\XML\Element\XMLElementString` is a shortcut for `XMLElementSimple` to provide XML as a string instead.
As `\SimpleXMLElement` is used, `XMLElementString` throws an exception,
if provided string can not be parsed as a valid XML,
including situations,
when more than one XML root tags exist.
It means, that any XML created by `XMLElement` might be parsed by `XMLElementString`.

`Xtuple\Util\XML\Element\XMLElementStruct` can be used to build XML from regular data.

.Using `Xtuple\Util\XML\Element\XMLElementStruct`
[source]
----
use Xtuple\Util\XML\Attribute\Collection\Map\ArrayMapXMLAttribute;
use Xtuple\Util\XML\Attribute\Type\Boolean\XMLAttributeBoolean;
use Xtuple\Util\XML\Attribute\XMLAttributeStruct;
use Xtuple\Util\XML\Element\Collection\Sequence\ArrayListXMLElement;
use Xtuple\Util\XML\Element\XMLElementString;
use Xtuple\Util\XML\Element\XMLElementStruct;

$element = new XMLElementStruct('Setup', 'Value', new ArrayMapXMLAttribute([
  new XMLAttributeStruct('database', 'phpunit'),
  new XMLAttributeBoolean('debug', true),
]), new ArrayListXMLElement([
  new XMLElementString('<Timezone>America/New_York</Timezone>'),
]));

$element->__toString() === '<Setup database="phpunit" debug="true"><Timezone>America/New_York</Timezone>Value</Setup>';
----

`Xtuple\Util\XML\Element\XMLElementSequence`
should be used to represent a list (sequence) of XML elements as an XML element.
`XMLElementSequence` name, value and attributes are always empty.

.Using `Xtuple\Util\XML\Element\XMLElementSequence`
[source]
----
use Xtuple\Util\XML\Element\Collection\Sequence\ArrayListXMLElement;
use Xtuple\Util\XML\Element\XMLElementSequence;

$element = new XMLElementSequence(new ArrayListXMLElement([
  new XMLElementString('<Name>phpunit</Name>'),
  new XMLElementString('<Debug>true</Debug>'),
  new XMLElementString('<Encoding>UTF-8</Encoding>'),
]));
// The following is true:
$element->name() === '';
$element->value() === '';
$element->attributes()->isEmpty() === true;
$element->isEmpty() === false;
$element->children('Name')->get(0)->value() === 'phpunit';
$element->__toString() === '<Name>phpunit</Name><Debug>true</Debug><Encoding>UTF-8</Encoding>';
----

=== Optional

`Xtuple\Util\XML\Element\Optional\OptionalXMLElement`
provides an implementation of an `XMLElement` that returns an empty string,
if the tag is empty (a regular implementation, should return an actual empty tag, e.g. `<br/>`).

`Xtuple\Util\XML\Element\Optional\OptionalXMLElementStruct`
is a shortcut for `OptionalXMLElement` with the same signature as `XMLElementStruct`.

.Using `Xtuple\Util\XML\Element\Optional\OptionalXMLElement`
[source]
----
use Xtuple\Util\XML\Element\Optional\OptionalXMLElement;
use Xtuple\Util\XML\Element\Optional\OptionalXMLElementStruct;
use Xtuple\Util\XML\Element\XMLElementStruct;

$element = new OptionalXMLElement(new XMLElementStruct('Debug', 'true'));
$element->__toString() === '<Debug>true</Debug>';
$element = new OptionalXMLElement(new XMLElementStruct('Debug'));
$element->__toString() === '';

$element = new OptionalXMLElementStruct('Debug', 'true');
$element->__toString() === '<Debug>true</Debug>';
$element = new OptionalXMLElementStruct('Debug');
$element->__toString() === '';
----

=== Strict types

`Xtuple\Util\XML\Element\XMLElement::value()` is a generic method, that always returns `string`.
For example,
`Xtuple\Util\XML\Element\Type\BooleanXMLElement::value()` returns strictly `bool` (`true` or `false`).
`Xtuple\Util\XML\Element\Type\AbstractTypeXMLElement` can be used to simplify adding new strictly typed XML elements.

.Using `Xtuple\Util\XML\Element\Type\Boolean` package
[source]
----
use Xtuple\Util\XML\Element\Type\Boolean\BooleanXMLElement;
use Xtuple\Util\XML\Element\Type\Boolean\OptionalXMLElementBoolean;
use Xtuple\Util\XML\Element\Type\Boolean\XMLElementBoolean;
use Xtuple\Util\XML\Element\XMLElementString;

$element = new XMLElementString('<Debug>true</Debug>');
$debug = new BooleanXMLElement($element->children('Debug')->get(0));
// Following is true:
$element->children('Debug')->get(0)->value() === 'true';
$debug->value() === true;

$element = new XMLElementBoolean('Debug', true);
$element->value() === 'true';

$element = new OptionalXMLElementBoolean('Debug', null);
$element->value() === '';
----

=== Collection

`Xtuple\Util\XML\Element\Collection\Sequence\ListXMLElement` is a default collection of XML elements
and `Xtuple\Util\XML\Element\Collection\Sequence\ArrayListXMLElement` is its default implementation.

`ListXMLElement::__toString()` must return an output of the elements in the same order as they are in the list.

.Using `Xtuple\Util\XML\Element\Collection\Sequence\ListXMLElement`
[source]
----
use Xtuple\Util\XML\Element\Collection\Sequence\ArrayListXMLElement;
use Xtuple\Util\XML\Element\XMLElementString;

$list = new ArrayListXMLElement([
  new XMLElementString('<Debug>true</Debug>'),
  new XMLElementString('<Test>false</Test>'),
]);
$list->__toString() === '<Debug>true</Debug><Test>false</Test>';
----
